import {
  derived,
  writable
} from "./chunk-7A3DOY4C.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  __publicField,
  action_destroyer,
  add_location,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  safe_not_equal,
  setContext,
  set_attributes,
  space,
  subscribe,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-DMCGU42Y.js";

// node_modules/consolite/esm/index.mjs
var defaults = {
  filter: "",
  level: 3,
  levels: {
    default: 3,
    error: 1,
    warn: 2,
    debug: 4,
    trace: 4
  }
};
var noop2 = (x) => x;
var unique = (v, i, a) => a.indexOf(v) === i;
var escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
var escapeIfString = (str) => typeof str === "string" ? escapeRegExp(str) : str;
var ExtendConsole = class {
  constructor(parent, options, prefix) {
    __publicField(this, "_filter", null);
    __publicField(this, "_level", null);
    __publicField(this, "_levels", {});
    __publicField(this, "_prefix", []);
    __publicField(this, "_delimiter", null);
    __publicField(this, "logMethods", {});
    __publicField(this, "levels", new Proxy(this._levels, {
      ownKeys: (target) => {
        var _a;
        return [
          ...Object.keys(defaults.levels),
          ...Object.keys(((_a = this.parent) == null ? void 0 : _a.levels) || {}),
          ...Reflect.ownKeys(target)
        ].filter(unique);
      },
      getOwnPropertyDescriptor: (target, key) => ({
        value: target[key],
        enumerable: true,
        configurable: true
      }),
      get: (target, prop) => {
        var _a, _b;
        return target[prop] || target.default || ((_a = this.parent) == null ? void 0 : _a.levels[prop]) || ((_b = this.parent) == null ? void 0 : _b.levels.default) || defaults.levels[prop] || defaults.levels.default;
      },
      set: (target, prop, value) => target[prop] = value
    }));
    this.parent = parent;
    this.options = options;
    if (!parent)
      this.logMethods = { ...console };
    Object.assign(this.logMethods, options == null ? void 0 : options.methods);
    this._prefix = prefix;
    Object.defineProperties(this, {
      _filter: { enumerable: false },
      _level: { enumerable: false },
      _levels: { enumerable: false },
      _prefix: { enumerable: false }
    });
  }
  createChild(optsOrPrefix, ...prefix) {
    const hasOptions = typeof optsOrPrefix === "object";
    const options = hasOptions ? optsOrPrefix : {};
    if (!hasOptions && optsOrPrefix)
      prefix.unshift(optsOrPrefix);
    return createProxy(this, options, prefix);
  }
  register(name, fn) {
    this.logMethods[name] = fn;
  }
  getNearest(cb) {
    const fn = typeof cb === "string" || typeof cb === "symbol" ? (x) => x[cb] : cb;
    const result = fn(this);
    return result !== null && result !== void 0 ? result : this.parent && this.parent.getNearest(fn);
  }
  get prefix() {
    let parent = this;
    const accumulatedPrefixes = [...this._prefix];
    while (parent = parent.parent)
      accumulatedPrefixes.unshift(...parent._prefix);
    return accumulatedPrefixes;
  }
  get formattedPrefixes() {
    if (!this.delimiter)
      return this.prefix;
    else {
      const prefixes = [];
      this.prefix.forEach((prefix) => prefixes.push(prefix, this.delimiter));
      return prefixes;
    }
  }
  get delimiter() {
    return this.getNearest("_delimiter");
  }
  set delimiter(value) {
    this._delimiter = value;
  }
  set prefix(value) {
    this._prefix = Array.isArray(value) ? value : [value];
  }
  get level() {
    var _a;
    const level = (_a = this.getNearest("_level")) != null ? _a : defaults.level;
    return typeof level === "function" ? level() : level;
  }
  set level(val) {
    this._level = val;
  }
  get filter() {
    var _a;
    return (_a = this.getNearest("_filter")) != null ? _a : defaults.filter;
  }
  set filter(val) {
    this._filter = val;
  }
  get __self() {
    return this;
  }
  get root() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.root) || this;
  }
};
var createProxy = (parent, options, prefix) => {
  const extendedConsole = new ExtendConsole(parent, options, prefix);
  const proxy = new Proxy(extendedConsole, {
    get(target, prop) {
      if (Reflect.has(target, prop))
        return Reflect.get(target, prop);
      const fn = target.getNearest((t) => t.logMethods[prop]);
      if (fn) {
        const withinLevel = (prop2) => target.levels[prop2] <= target.level;
        const passesFilter = () => typeof target.filter === "function" ? target.filter(target.prefix, prop) : target.prefix.join("").match(escapeIfString(target.filter));
        const canBind = typeof fn === "function";
        const shouldPrint = withinLevel(prop) && passesFilter() && canBind;
        const prefixes = target.formattedPrefixes.map(
          (p) => typeof p === "string" ? p : p(prop)
        );
        return shouldPrint ? fn.bind(console, ...prefixes) : noop2;
      }
    },
    set(target, prop, value) {
      if (Reflect.has(target, prop))
        target[prop] = value;
      else if (value instanceof Function)
        target.logMethods[prop] = value;
      else
        return false;
      return true;
    },
    ownKeys(target) {
      const keys = [...Reflect.ownKeys(target), ...Reflect.ownKeys(target.logMethods)];
      let parent2 = target;
      while (parent2 = parent2.parent)
        keys.push(...Reflect.ownKeys(parent2.logMethods));
      return keys;
    },
    getOwnPropertyDescriptor(target, prop) {
      if (Reflect.get(target, prop))
        return Object.getOwnPropertyDescriptor(target, prop);
      return parent && parent.getNearest((t) => Object.getOwnPropertyDescriptor(t.logMethods, prop)) || void 0;
    }
  });
  return proxy;
};
var createLogger = (optsOrPrefix, ...prefix) => {
  const hasOptions = typeof optsOrPrefix === "object";
  const options = hasOptions ? optsOrPrefix : {};
  if (!hasOptions && optsOrPrefix)
    prefix.unshift(optsOrPrefix);
  return createProxy(void 0, options, prefix);
};

// node_modules/@roxi/routify/lib/runtime/utils/logger.js
var log = createLogger("[rf3]");
log.register("verbose", console.log);
log.levels.verbose = 5;
var createRootLogger = () => {
  Object.assign(log, loadState());
  return new Proxy(log, {
    get: (target, prop) => target[prop],
    set: (target, prop, value) => {
      target[prop] = value;
      saveState(log);
      return true;
    }
  });
};
var loadState = () => {
  if (typeof window === "undefined") {
    const level = process.env.DEBUG_LEVEL;
    const filter = process.env.DEBUG_FILTER;
    return { level, filter };
  } else {
    return JSON.parse(localStorage.getItem("__routify.logState") || "{}");
  }
};
var saveState = (log2) => {
  const { level, filter } = log2;
  if (typeof window === "undefined") {
    process.env.DEBUG_LEVEL = level;
    process.env.DEBUG_FILTER = filter;
  } else
    localStorage.setItem("__routify.logState", JSON.stringify({ filter, level }));
};
var debugWrapper = (fn, msg) => (...params2) => {
  const result = fn(...params2);
  log.debug(msg, { params: params2, result });
  return result;
};

// node_modules/@roxi/routify/lib/runtime/Global/BrowserAdapter.js
var createBrowserAdapter = (opts) => {
  const delimiter = (opts == null ? void 0 : opts.delimiter) || ";";
  return {
    toRouter: (url2, router) => {
      const formatRE = router.name ? `${router.name}=(.+?)` : `(.+?)`;
      const RE = new RegExp(`(^|${delimiter})${formatRE}(${delimiter}|$)`);
      const matches = url2.match(RE);
      return matches ? matches[2] : "/";
    },
    toBrowser: (routers) => routers.map((r) => (r.name ? `${r.name}=` : "") + r.url.external()).join(delimiter)
  };
};

// node_modules/@roxi/routify/lib/runtime/Global/Global.js
var AppInstance = class {
  constructor() {
    __publicField(this, "instances", []);
    __publicField(this, "routeMaps", {});
    __publicField(this, "browserAdapter", createBrowserAdapter());
    __publicField(this, "urlFromBrowser", (router) => {
      if (debugWrapper)
        return debugWrapper(
          this.browserAdapter.toRouter,
          "calling browserAdapter.toRouter"
        )(urlFromAddress(), router);
      return this.browserAdapter.toRouter(urlFromAddress(), router);
    });
    globalThis["__routify"] = this;
    this.log = createRootLogger();
  }
  get routers() {
    return [].concat(...this.instances.map((instance8) => instance8.routers));
  }
  register(instance8) {
    this.instances.push(instance8);
    return this;
  }
};
var appInstance = new AppInstance();

// node_modules/@roxi/routify/lib/runtime/utils/index.js
var CTX = "routify-fragment-context";
var getRoutifyFragmentContext = () => getContext(CTX);
var getRoutifyFragmentContextMaybe = () => {
  try {
    const ctx = getRoutifyFragmentContext();
    return ctx;
  } catch (e) {
  }
};
var setRoutifyFragmentContext = (value) => setContext(CTX, value);
var shouldIgnoreClick = (event) => event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button || event.key && event.key !== "Enter" || event.defaultPrevented;
var parseValue = (value) => {
  try {
    return JSON.parse(value);
  } catch (error) {
    return value;
  }
};
var extractRoutifyStateData = (el) => {
  const routifyRouteState = {};
  for (let key in el.dataset) {
    if (key.startsWith("routifyRouteState")) {
      const shortKey = key.replace("routifyRouteState", "");
      const finalKey = shortKey.charAt(0).toLowerCase() + shortKey.slice(1);
      routifyRouteState[finalKey] = parseValue(el.dataset[key]);
    }
  }
  return routifyRouteState;
};
var getUrlFromEvent = (event) => {
  const el = event.target.closest("a");
  const href = el && el.href;
  if (!href || el.target || el.host !== location.host)
    return {};
  const urlObj = new URL(href);
  event.preventDefault();
  return {
    url: urlObj.pathname + urlObj.search + urlObj.hash,
    state: extractRoutifyStateData(el)
  };
};
var fromEntries = (iterable) => {
  return [...iterable].reduce((obj, [key, val]) => {
    obj[key] = val;
    return obj;
  }, {});
};
var populateUrl = (path, params2, overloadStringifier) => {
  const overloads = {};
  Object.entries(params2).forEach(([param, value]) => {
    const RE = new RegExp(`\\[(...)?${param}\\]|\\:${param}`);
    value = Array.isArray(value) ? value.join("/") : value;
    if (path.match(RE))
      path = path.replace(RE, encodeURI(value));
    else
      overloads[param] = value;
  });
  const query = overloadStringifier(overloads);
  return path + query;
};
var urlFromAddress = () => (({ pathname, search, hash }) => pathname + search + hash)(window.location);
var getGlobalContext = () => {
  console.log("Using helpers outside router context is not supported. Use at own risk.");
  const router = appInstance.routers[0];
  const route = router.activeRoute.get() || router.pendingRoute.get();
  return {
    elem: null,
    anchorLocation: null,
    options: null,
    childFragments: writable(route.allFragments),
    node: router.rootNode,
    fragment: route.allFragments[0],
    isActive: writable(false),
    isVisible: writable(false),
    inline: null,
    router,
    route,
    parentContext: null,
    onDestroy: null,
    decorators: [],
    scrollBoundary: null,
    isInline: null,
    mounted: null
  };
};
var contexts = {
  get router() {
    return (getRoutifyFragmentContext() || getGlobalContext()).router;
  },
  get fragment() {
    return getRoutifyFragmentContext() || getGlobalContext();
  }
};
var getable = (value, start) => {
  const store = writable(value, start);
  return Object.assign(store, { get: () => get_store_value(store) });
};
var identicalRoutes = (...routes) => routes.map((route) => JSON.stringify([route == null ? void 0 : route.allFragments, route == null ? void 0 : route.url])).reduce((prev, curr) => prev === curr && curr);
var isAnonFn = (input) => typeof input === "function" && !input.prototype;
var resolveIfAnonFn = (subject, params2) => isAnonFn(subject) ? subject(...params2) : subject;
var pushToOrReplace = (arr, input) => {
  const _isAnonFn = isAnonFn(input);
  input = _isAnonFn || Array.isArray(input) ? input : [input];
  const res = _isAnonFn ? input([...arr]) : [...arr, ...input];
  if (!Array.isArray(res))
    throw new Error("anonymous callback did not return array");
  return res;
};
var waitFor = (store, cb) => new Promise((resolve, reject) => {
  try {
    const unsub = store.subscribe((val) => {
      if (cb(val)) {
        resolve(val);
        setTimeout(() => unsub);
      }
    });
  } catch (err) {
    reject(err);
  }
});
var createDeferredPromise = () => {
  let resolve, reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return Object.assign(promise, { resolve, reject });
};

// node_modules/@roxi/routify/lib/runtime/utils/messages.js
var couldNotFindRoutes = (name) => `Could not find routes for the router '${name}'. Please use the 'routes' prop or create a route tree named '${name}'.
Eg. routesDir: {
    default: 'src/routes',
    ${name}: 'src/widget',
}`;
var noRoutesMapProvided = (name) => `No routesMap provided. Make sure you've either created a router for the '${name}' route or provided a routesMap`;
var handleRebuildError = (context2, childContexts) => {
  console.warn("Failed to rebuild routes", { context: context2, childContexts });
  const msg = "Infinite loop detected while trying to compose components. This is likely an error in Routify.";
  const err = new Error(msg);
  throw err;
};

// node_modules/@roxi/routify/lib/runtime/helpers/preload.js
var getWindowUrl = () => typeof window === "undefined" ? "" : window.location.pathname + window.location.search + window.location.hash;
var preloadUrl = (urlOrOptions) => {
  var _a, _b, _c, _d;
  const options = typeof urlOrOptions === "string" || Array.isArray(urlOrOptions) ? { url: urlOrOptions } : urlOrOptions;
  let { url: url2, routesMap } = options;
  url2 = (_d = (_c = url2 != null ? url2 : (_a = import.meta["env"]) == null ? void 0 : _a.ROUTIFY_URL) != null ? _c : (_b = import.meta["env"]) == null ? void 0 : _b.URL) != null ? _d : getWindowUrl();
  const urls = Array.isArray(url2) ? url2 : [url2];
  return Promise.all(
    urls.map((url3) => preloadUrlFromUrlPairs(getUrlSegments(url3), routesMap))
  );
};
var createNewRouter = async (name, url2, routesMap) => {
  const fullName = name || "default";
  if (!routesMap)
    console.error(noRoutesMapProvided(fullName));
  const getRoutes = routesMap[fullName];
  if (!getRoutes) {
    console.error(couldNotFindRoutes(fullName));
    return false;
  }
  return createRouter({ name, url: url2, routes: await getRoutes() });
};
var preloadUrlFromUrlPairs = async (urlPairs, routesMap) => {
  const routerPromises = urlPairs.map(async ([name, url2]) => {
    const matchingRouter = appInstance.routers.find((router2) => router2.name === name);
    const router = matchingRouter || await createNewRouter(name, url2, routesMap);
    if (!router)
      return false;
    const currentRoute = router.pendingRoute.get() || router.activeRoute.get();
    if ((currentRoute == null ? void 0 : currentRoute.url) !== url2)
      router.url.replace(url2);
    return router;
  });
  const routers = await Promise.all(routerPromises);
  await Promise.all(routers.map((router) => router && router.ready()));
  return routers.map((router) => router.activeRoute.get().load);
};
var getUrlSegments = (compositeUrl) => compositeUrl.split(";").map(urlSegmentToRouterAndUrl);
var urlSegmentToRouterAndUrl = (urlSegment, index) => {
  if (!index)
    return ["", urlSegment];
  const matches = urlSegment.match(/([\w-]+?)=(.+)/);
  return [matches[1], matches[2]];
};
var getPrimaryUrl = (urlPairs) => urlPairs.find(([name]) => name === "")[1];

// node_modules/@roxi/routify/lib/runtime/helpers/index.js
var getMRCA = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  return lineage1.find((node3) => lineage2.includes(node3));
};
var getPath = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  const mrca = getMRCA(node1, node2);
  const backtrackSteps = lineage1.indexOf(mrca);
  const backtrackStr = backtrackSteps ? "../".repeat(backtrackSteps) : "";
  const forwardSteps = lineage2.indexOf(mrca);
  const forwardStepsStr = lineage2.slice(0, forwardSteps).reverse().map((n) => n.name).join("/");
  return backtrackStr + forwardStepsStr;
};
var goto = {
  subscribe: (run, invalidate) => {
    const { router } = contexts;
    return derived(url, ($url) => (path, userParams, options) => {
      const defaults2 = { mode: "push", state: {} };
      options = { ...defaults2, ...options };
      const newUrl = $url(path, userParams, options);
      router.url[options.mode](newUrl, options.state);
      return "";
    }).subscribe(run, invalidate);
  }
};
var _url = {
  subscribe: (run, invalidate) => {
    const { fragment, router } = contexts;
    return derived(fragment.params, ($params) => {
      return createUrl(fragment.fragment, router);
    }).subscribe(run, invalidate);
  }
};
var url = {
  subscribe: (run, invalidate) => {
    let InitialElem, initialParams, initialPath;
    const updateHref = ($url) => InitialElem.setAttribute("href", $url(initialPath, ...initialParams));
    return derived(_url, ($url) => {
      if (InitialElem) {
        updateHref($url);
      }
      return (pathOrElem, ...params2) => {
        if (typeof pathOrElem != "object") {
          return $url(pathOrElem, ...params2);
        }
        InitialElem = pathOrElem;
        initialParams = params2;
        initialPath = InitialElem.getAttribute("href");
        updateHref($url);
      };
    }).subscribe(run, invalidate);
  }
};
var createUrl = (fragment, router) => (_inputPath, userParams = {}, options = {}) => {
  const route = fragment.route;
  const originNode = router.rootNode.traverse(fragment.node.path);
  const inputPath = _inputPath.replace("$leaf", (route == null ? void 0 : route.url) || fragment.node.path);
  const offset = inputPath.startsWith("/") ? router.rootNode.path : "";
  const targetNode = originNode.traverse(
    offset + inputPath,
    !options.strict,
    options.includeIndex,
    options.silent
  );
  if (!targetNode) {
    console.error("could not find destination node", inputPath);
    return;
  }
  const mrca = getMRCA(targetNode, router.rootNode);
  const path = ("/" + getPath(mrca, targetNode)).replace(/\/index$/, "/");
  const params2 = {
    ...inheritedParams(targetNode, route || router.activeRoute.get()),
    ...userParams
  };
  const urlHandler = (obj) => router.queryHandler.stringify(obj, route);
  const internalUrl = populateUrl(path, params2, urlHandler);
  const externalUrl = router.getExternalUrl(internalUrl);
  return externalUrl;
};
var inheritedParams = (node2, route) => {
  const params2 = route.allFragments.map(
    (fragment) => fragment.node.getChainToNode(node2) && fragment.params
  );
  return Object.assign({}, ...params2);
};
var params = {
  subscribe: (run, invalidate) => {
    return derived(
      [contexts.router.params, contexts.fragment.params],
      ([routerParams, fragmentParams]) => ({ ...routerParams, ...fragmentParams })
    ).subscribe(run, invalidate);
  }
};
var isActive = {
  subscribe: (run, invalidate) => {
    const { fragment, router } = contexts;
    return derived(router.activeRoute, () => isActiveUrl(fragment)).subscribe(
      run,
      invalidate
    );
  }
};
var traverseContext = (context2, path, params2) => {
  const breadcrumbs = path.split("/");
  let targetContexts = [context2];
  for (const crumb of breadcrumbs) {
    if (!targetContexts)
      return false;
    if (crumb === "..") {
      targetContexts = [targetContexts[0].parentContext];
    } else if (crumb != ".") {
      const childContexts = targetContexts.map((ctx) => get_store_value(ctx.childContexts)).flat();
      targetContexts = childContexts.filter(
        (childContext) => childContext.node.name === crumb
      );
    }
  }
  const targetContext = targetContexts.find((ctx) => {
    const paramsStores = [ctx.params, ...ctx.ancestors.map((ctx2) => ctx2.params)];
    const existingParams = Object.assign({}, ...paramsStores.map((store) => get_store_value(store)));
    const allParamsArePresent = Object.entries(params2).every(
      ([key, value]) => existingParams[key] === value
    );
    return allParamsArePresent;
  });
  return targetContext;
};
var isActiveFragment = {
  subscribe: (run, invalidate) => {
    const { fragment: context2, router } = contexts;
    const refresh = () => {
      run((path, params2, options) => {
        options = { recursive: false, ...options };
        const targetContext = traverseContext(context2, path, params2);
        if (!targetContext)
          return false;
        const isActiveStores = [
          targetContext.isActive,
          ...options.recursive && targetContext.ancestors.map((ctx) => ctx.isActive) || []
        ];
        const isActive2 = isActiveStores.map((store) => get_store_value(store)).every(Boolean);
        return isActive2;
      });
    };
    refresh();
    return router.activeRoute.subscribe(
      () => router.ready().then(refresh),
      invalidate
    );
  }
};
var isActiveUrl = (renderContext) => {
  const { router, fragment } = renderContext;
  return (path, params2 = {}, options = {}) => {
    const { recursive } = { recursive: true, ...options };
    const route = router.activeRoute.get();
    const chainOptions = {
      rootNode: router.rootNode,
      allowDynamic: false,
      includeIndex: !recursive
    };
    const allWantedParamsAreInActiveChain = Object.entries(params2).every(
      ([key, value]) => route.params[key] === value
    );
    if (!allWantedParamsAreInActiveChain)
      return false;
    const wantedNode = path.startsWith(".") ? fragment.node.traverse(path) : router.rootNode.getChainTo(path, chainOptions).pop().node;
    const actNodes = [...route.fragments.map((fragment2) => fragment2.node)];
    return actNodes.includes(wantedNode);
  };
};
var resolveNode = (path) => {
  const { node: node2 } = contexts.fragment;
  const { router } = contexts;
  return traverseNode(node2, path, router);
};
var traverseNode = (node2, path, router) => path.startsWith("/") ? router.rootNode.traverse(`.${path}`) : node2.traverse(path);
var pseudoStore = (callback) => ({
  subscribe: (run) => {
    run(callback());
    return () => {
    };
  }
});
var context = pseudoStore(() => contexts.fragment);
var node = pseudoStore(() => get_store_value(context).node);
var meta = pseudoStore(() => get_store_value(node).meta);
var activeRoute = {
  subscribe: (run) => contexts.router.activeRoute.subscribe(run)
};
var pendingRoute = {
  subscribe: (run) => contexts.router.pendingRoute.subscribe(run)
};
var afterUrlChange = {
  subscribe: (run) => {
    const hookHandles = [];
    const register = (callback) => {
      const unhook = contexts.router.afterUrlChange(callback);
      hookHandles.push(unhook);
      return unhook;
    };
    run(register);
    return () => hookHandles.map((unhook) => unhook());
  }
};
var beforeUrlChange = {
  subscribe: (run) => {
    const hookHandles = [];
    const register = (callback) => {
      const unhook = contexts.router.beforeUrlChange(callback);
      hookHandles.push(unhook);
      return unhook;
    };
    run(register);
    return () => hookHandles.map((unhook) => unhook());
  }
};

// node_modules/@roxi/routify/lib/runtime/Route/utils.js
var uriDecodeStringOrArray = (strOrArr) => strOrArr instanceof Array ? strOrArr.map(decodeURI) : decodeURI(strOrArr);
var URIDecodeObject = (obj) => Object.entries(obj).reduce(
  (_return, [key, value]) => ({
    ..._return,
    [key]: uriDecodeStringOrArray(value)
  }),
  {}
);
var LoadCache = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  async fetch(id, options) {
    if (!this.map.has(id))
      this.map.set(id, options.hydrate());
    this._handlePromise(id, options);
    return this.map.get(id);
  }
  async _handlePromise(id, options) {
    var _a;
    const value = await this.map.get(id);
    const clear = (_a = options.clear) == null ? void 0 : _a.call(options, value);
    if (typeof clear === "number")
      setTimeout(() => this.map.delete(id), clear);
    else if (clear)
      this.map.delete(id);
  }
};

// node_modules/@roxi/routify/lib/runtime/Route/RouteFragment.js
var RouteFragment = class {
  constructor(route, node2, urlFragment = "", params2 = {}) {
    this.route = route;
    this.node = node2;
    this.load = void 0;
    this.urlFragment = urlFragment;
    this.params = params2;
    this.renderContext = createDeferredPromise();
    Object.defineProperty(this, "route", { enumerable: false });
    this.params = URIDecodeObject({ ...this.node.meta.isDefault, ...params2 });
  }
};

// node_modules/@roxi/routify/lib/runtime/Route/Route.js
var URL_STATES = ["pushState", "replaceState", "popState"];
var loadCache = new LoadCache();
var Route = class {
  constructor(router, url2, mode, state = {}) {
    __publicField(this, "allFragments", []);
    __publicField(this, "fragments", []);
    __publicField(this, "load", {
      status: 200,
      error: null,
      maxage: null,
      props: {},
      redirect: null
    });
    this.sourceUrl = typeof url2 === "string" ? new URL(url2, "http://localhost") : url2;
    this.router = router;
    this.mode = mode;
    this.state = state;
    this.state.createdAt = new Date();
    if (!router.rootNode) {
      const err = new Error(
        "Can't navigate without a rootNode. Have you imported routes?"
      );
      Object.assign(err, { routify: { router } });
      throw err;
    }
    if (!URL_STATES.includes(mode))
      throw new Error("url.mode must be pushState, replaceState or popState");
    this.allFragments = this._createFragments(this.sourceUrl.pathname);
    this.params = { ...this.queryParams, ...this.fragmentParams };
    this.fragments = this.router.transformFragments.run(this.allFragments);
    this.url = this._createUrl();
    this.log = router.log.createChild("[route]");
    this.log.debug("created", this);
  }
  get fragmentParams() {
    return this.allFragments.reduce((acc, curr) => ({ ...acc, ...curr.params }), {});
  }
  get queryParams() {
    return this.router.queryHandler.parse(this.sourceUrl.search, this);
  }
  get leaf() {
    return [...this.fragments].pop();
  }
  get isPendingOrPrefetch() {
    return this === this.router.pendingRoute.get() || this.state.prefetch;
  }
  async loadRoute() {
    const pipeline = [
      this.runBeforeUrlChangeHooks,
      this.loadComponents,
      this.runPreloads
    ];
    for (const pretask of pipeline) {
      const passedPreTask = await pretask.bind(this)();
      if (!this.isPendingOrPrefetch || !passedPreTask)
        return false;
    }
    this.log.debug("loaded route", this);
    return true;
  }
  async loadComponents() {
    this.log.debug("load components", this);
    const nodes = this.fragments.map((fragment) => fragment.node);
    const multiNodes = nodes.map((node2) => node2.children.find((node3) => node3.name === "_decorator")).filter(Boolean);
    await Promise.all([...nodes, ...multiNodes].map((node2) => node2.loadModule()));
    return true;
  }
  async runPreloads() {
    var _a;
    this.log.debug("run preloads", this);
    const prevRoute = this.router.activeRoute.get();
    for (const [index, fragment] of this.fragments.entries()) {
      if (!this.isPendingOrPrefetch)
        return false;
      const prevFragmentInSpot = prevRoute == null ? void 0 : prevRoute.fragments[index];
      const isSameBranch = fragment.node === (prevFragmentInSpot == null ? void 0 : prevFragmentInSpot.node);
      const ctx = {
        route: this,
        url: createUrl(fragment, this.router),
        prevRoute,
        isNew: !isSameBranch,
        fetch
      };
      if ((_a = fragment.node.module) == null ? void 0 : _a.load) {
        const cacheId = JSON.stringify([this.params, fragment.node.id]);
        const load = await loadCache.fetch(cacheId, {
          hydrate: () => fragment.node.module.load(ctx),
          clear: (res) => (res == null ? void 0 : res.expire) || !this.state.prefetch
        });
        fragment.load = {
          ...isSameBranch && prevFragmentInSpot.load,
          ...load
        };
        Object.assign(this.load, fragment.load);
        if (this.load.redirect && !this.state.prefetch)
          return this.router.url.replace(this.load.redirect, {
            redirectedBy: this
          });
      }
    }
    return this;
  }
  async runBeforeUrlChangeHooks() {
    return await this.router.beforeUrlChange.run({ route: this });
  }
  get meta() {
    return this.fragments.reduce((acc, curr) => ({ ...acc, ...curr.node.meta }), {});
  }
  createFragment(node2, urlFragment = "", params2 = {}) {
    return new RouteFragment(this, node2, urlFragment, params2);
  }
  _createFragments(pathname) {
    const rootNode = this.router.rootNode;
    const nodeChain = this.router.rootNode.getChainTo(pathname, {
      rootNode,
      allowDynamic: true,
      includeIndex: true,
      navigableChildrenOnly: true
    });
    const fragments = nodeChain.map(
      (nc) => this.createFragment(nc.node, nc.fragment, nc.params)
    );
    return fragments;
  }
  _createUrl() {
    const queryStringifier = (obj) => this.router.queryHandler.stringify(obj, this);
    const path = this.allFragments.map((f, i) => i ? f.node.name : "").join("/");
    const populatedUrl = populateUrl(path, this.params, queryStringifier);
    return populatedUrl.replace(/\/index$/, "") + this.sourceUrl.hash;
  }
};

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/ReflectorBase.js
var BaseReflector = class {
  constructor(router) {
    this.router = router;
    this.log = this.router.log;
  }
  install() {
  }
  uninstall() {
  }
  reflect() {
  }
};

// node_modules/@roxi/routify/lib/common/utils.js
var next = (store, wanted, strict) => new Promise((resolve) => {
  let unsub;
  unsub = store.subscribe((value) => {
    if (!unsub)
      return;
    if (typeof wanted === "undefined" || value === wanted || value == wanted && !strict || typeof wanted === "function" && wanted(value)) {
      resolve(value);
      unsub;
    }
  });
});
var createThrottle = () => {
  const map = /* @__PURE__ */ new Map();
  const throttle2 = async (fn) => {
    const fnStr = fn.toString();
    map.set(fnStr, map.get(fnStr) || { isRunning: false, runAgain: false });
    const s = map.get(fnStr);
    if (s.isRunning)
      s.runAgain = true;
    else {
      s.isRunning = true;
      await fn();
      s.isRunning = false;
      if (s.runAgain) {
        s.runAgain = false;
        await throttle2(fn);
      }
    }
  };
  return throttle2;
};
var throttle = createThrottle();
var lazySet = (store, value) => JSON.stringify(get_store_value(store)) !== JSON.stringify(value) && store.set(value);
var jsonClone = (obj) => JSON.parse(JSON.stringify(obj));
var initializeCache = (idGenerator, defaultContext) => {
  const functionCache = /* @__PURE__ */ new Map();
  const retrieveFromCache = (dataProducer, context2) => {
    const uniqueId = idGenerator();
    if (!functionCache.has(dataProducer)) {
      functionCache.set(dataProducer, /* @__PURE__ */ new Map());
    }
    const cache = functionCache.get(dataProducer);
    if (!cache.has(uniqueId)) {
      cache.set(uniqueId, dataProducer.bind(defaultContext || context2 || void 0)());
    }
    return cache.get(uniqueId);
  };
  retrieveFromCache.storage = functionCache;
  return retrieveFromCache;
};

// node_modules/@roxi/routify/lib/common/RNode.js
var RNode = class {
  constructor(name, module, instance8) {
    __publicField(this, "parent");
    __publicField(this, "meta", {});
    __publicField(this, "id");
    this.instance = instance8;
    this.name = name || "";
    instance8.nodeIndex.push(this);
    this.module = module;
    this._cacheByName = initializeCache(() => this.name, this);
    Object.defineProperty(this, "_cacheByName", { enumerable: false });
    Object.defineProperty(this, "instance", { enumerable: false });
    Object.defineProperty(this, "parent", { enumerable: false });
  }
  appendChild(child) {
    if (child.instance)
      child.parent = this;
  }
  createChild(name, module) {
    const node2 = this.instance.createNode(name, module);
    this.appendChild(node2);
    return node2;
  }
  get descendants() {
    return this.instance.nodeIndex.filter(
      (node2) => node2.ancestors.find((n) => n === this)
    );
  }
  remove() {
    const { nodeIndex } = this.instance;
    const index = nodeIndex.findIndex((node2) => node2 === this);
    nodeIndex.splice(index, 1);
  }
  get ancestors() {
    let node2 = this;
    const ancestors = [];
    while (node2 = node2.parent)
      ancestors.push(node2);
    return ancestors;
  }
  get root() {
    let node2 = this;
    while (node2.parent)
      node2 = node2.parent;
    return node2;
  }
  get isRoot() {
    return this === this.root;
  }
  get children() {
    return this.instance.nodeIndex.filter((node2) => node2.parent === this).sort((prev, curr) => (prev.meta.order || 0) - (curr.meta.order || 0));
  }
  get navigableChildren() {
    return this.children.filter((node2) => !node2.meta.noRoute);
  }
  get linkableChildren() {
    return this.navigableChildren.filter((node2) => node2.meta.order != false);
  }
  get level() {
    var _a;
    return (((_a = this.parent) == null ? void 0 : _a.level) || 0) + 1;
  }
  _getRegex() {
    return this.instance.utils.getRegexFromName(this.name);
  }
  get regex() {
    return this._cacheByName(this._getRegex);
  }
  _getParamKeys() {
    return this.instance.utils.getFieldsFromName(this.name);
  }
  get paramKeys() {
    return this._cacheByName(this._getParamKeys);
  }
  _getSpecificity() {
    return [this.name.replace(/\[.+?\]/g, "").length, this.paramKeys.length];
  }
  get specificity() {
    return this._cacheByName(this._getSpecificity);
  }
  getParams(urlFragment) {
    if (urlFragment.match(/^\.+$/))
      return {};
    const values = this.instance.utils.getValuesFromPath(this.regex, urlFragment);
    return this.instance.utils.mapFieldsWithValues(this.paramKeys, values);
  }
  traverse(path, allowDynamic = false, includeIndex = false, silent = false) {
    var _a;
    const isNamed = !path.startsWith("/") && !path.startsWith(".");
    return isNamed ? this.root.instance.nodeIndex.find((node2) => node2.meta.name === path) : (_a = this.getChainTo(path, { allowDynamic, includeIndex, silent })) == null ? void 0 : _a.pop().node;
  }
  getChainTo(path, options) {
    options = {
      ...{ allowDynamic: true, includeIndex: true, navigableChildrenOnly: false },
      ...options
    };
    const targetChildren = options.navigableChildrenOnly ? "navigableChildren" : "children";
    const originNode = path.startsWith("/") ? options.rootNode || this.root : this;
    const stepsToLeaf = path.split("/").filter((snip) => snip !== ".").filter(Boolean);
    let currentNodeStep = {
      node: originNode,
      stepsToLeaf,
      params: {},
      fragment: ""
    };
    const nodeSteps = [currentNodeStep];
    let inStaticDeadEnd = false;
    let inDynamicDeadEnd = false;
    while (currentNodeStep.stepsToLeaf.length) {
      const [nextStep, ...restSteps] = currentNodeStep.stepsToLeaf;
      const nextNode = nextStep === ".." ? currentNodeStep.node.parent : !inStaticDeadEnd && currentNodeStep.node[targetChildren].find(
        (node2) => node2.name === nextStep
      ) || options.allowDynamic && !inDynamicDeadEnd && [...currentNodeStep.node[targetChildren]].sort(
        (a, b) => b.specificity[0] - a.specificity[0] || b.specificity[1] - a.specificity[1]
      ).filter(({ meta: meta2 }) => meta2.dynamic && !meta2.dynamicSpread).find((node2) => node2.regex.test(nextStep)) || options.allowDynamic && currentNodeStep.node[targetChildren].find(
        (node2) => node2.meta.dynamicSpread
      );
      if (nextNode) {
        const nodeStep = {
          node: nextNode,
          params: nextNode.meta.dynamicSpread ? [nextStep] : nextNode.meta.dynamic ? nextNode.getParams(nextStep) : {},
          stepsToLeaf: restSteps,
          fragment: nextStep
        };
        currentNodeStep = nodeStep;
        nodeSteps.push(nodeStep);
      } else if (!options.allowDynamic && options.silent)
        return null;
      else if (!options.allowDynamic && !options.silent)
        throw new Error(
          `${nodeSteps.map((ns) => ns.node.name || "root").join("/")} could not travel to ${nextStep}`
        );
      else if (currentNodeStep.node.meta.dynamicSpread) {
        currentNodeStep.params.push(nextStep);
        currentNodeStep.fragment += `/${nextStep}`;
        currentNodeStep.stepsToLeaf.shift();
        inDynamicDeadEnd = false;
        inStaticDeadEnd = false;
      } else {
        nodeSteps.pop();
        currentNodeStep = [...nodeSteps].pop();
        inDynamicDeadEnd = inStaticDeadEnd;
        inStaticDeadEnd = true;
        if (!currentNodeStep && options.silent)
          return null;
        else if (!currentNodeStep && !options.silent)
          throw new Error(`Could not find path "${path}" from ${this.name}`);
      }
    }
    try {
      const indexNode = options.includeIndex && currentNodeStep.node[targetChildren].find(
        (node2) => node2.name === "index" || node2.meta.isDefault
      );
      if (indexNode)
        nodeSteps.push({
          node: indexNode,
          stepsToLeaf: [],
          params: {},
          fragment: ""
        });
    } catch (err) {
    }
    nodeSteps.forEach((ns) => {
      ns.params = Array.isArray(ns.params) ? { [ns.node.name.replace(/\[\.\.\.(.+)\]/, "$1")]: ns.params } : ns.params;
    });
    return nodeSteps;
  }
  getChainToNode(node2) {
    const chain = [];
    do {
      chain.unshift(node2);
      if (node2 === this)
        return chain;
    } while (node2 = node2.parent);
  }
  toJSON() {
    return {
      ...this,
      children: [...this.children]
    };
  }
  get path() {
    return "/" + [this, ...this.ancestors].reverse().map((node2) => node2.name).filter(Boolean).join("/");
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/Node.svelte
function create_else_block(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(21:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[0], { context: ctx[2] }];
  var switch_value = ctx[1];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & 5 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 1 && get_spread_object(ctx2[0]),
        dirty & 4 && { context: ctx2[2] }
      ]) : {};
      if (dirty & 32) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & 2 && switch_value !== (switch_value = ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(17:0) {#if Component}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(18:4) <svelte:component this={Component} {...passthrough} {context}>",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Node", slots, ["default"]);
  let { node: node2 } = $$props;
  let { passthrough } = $$props;
  const context2 = { ...getRoutifyFragmentContext(), node: node2 };
  setRoutifyFragmentContext(context2);
  let Component = (_a = node2.module) == null ? void 0 : _a.default;
  if (!Component && node2.asyncModule)
    node2.asyncModule().then((r) => $$invalidate(1, Component = r.default));
  $$self.$$.on_mount.push(function() {
    if (node2 === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<Node> was created without expected prop 'node'");
    }
    if (passthrough === void 0 && !("passthrough" in $$props || $$self.$$.bound[$$self.$$.props["passthrough"]])) {
      console.warn("<Node> was created without expected prop 'passthrough'");
    }
  });
  const writable_props = ["node", "passthrough"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Node> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(3, node2 = $$props2.node);
    if ("passthrough" in $$props2)
      $$invalidate(0, passthrough = $$props2.passthrough);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getRoutifyFragmentContext,
    setRoutifyFragmentContext,
    node: node2,
    passthrough,
    context: context2,
    Component
  });
  $$self.$inject_state = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(3, node2 = $$props2.node);
    if ("passthrough" in $$props2)
      $$invalidate(0, passthrough = $$props2.passthrough);
    if ("Component" in $$props2)
      $$invalidate(1, Component = $$props2.Component);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [passthrough, Component, context2, node2, slots, $$scope];
}
var Node = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { node: 3, passthrough: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Node",
      options,
      id: create_fragment.name
    });
  }
  get node() {
    throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passthrough() {
    throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passthrough(value) {
    throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Node_default = Node;

// node_modules/@roxi/routify/lib/runtime/Instance/RNodeRuntime.js
var RNodeRuntime = class extends RNode {
  constructor(name, module, instance8, asyncModule) {
    super(name, module, instance8);
    __publicField(this, "asyncModule");
    __publicField(this, "importTree", (snapshotRoot) => {
      const queue = [[this, snapshotRoot]];
      while (queue.length) {
        const [node2, snapshot] = queue.pop();
        const { children: children2, ...nodeSnapshot } = snapshot;
        Object.assign(node2, nodeSnapshot);
        for (const childSnapshot of children2) {
          const childNode = node2.createChild(
            snapshot.name || snapshot.rootName || ""
          );
          queue.push([childNode, childSnapshot]);
        }
      }
      return this;
    });
    this.module = module;
    this.asyncModule = asyncModule;
  }
  get pages() {
    console.log("DEPRECATED node.pages: use .linkableChildren instead");
    return this.pagesWithIndex.filter((node2) => node2.name !== "index");
  }
  get title() {
    const getPrettyName = () => this.name.replace(/-/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
    const getTitle = () => this.meta.title || getPrettyName();
    return getTitle();
  }
  get pagesWithIndex() {
    console.log("DEPRECATED node.pagesWithIndex: use .linkableChildren instead");
    return this.children.filter((node2) => !node2.meta.fallback).filter((node2) => !node2.name.startsWith("_")).filter((node2) => !node2.name.includes("[")).filter((node2) => {
      var _a;
      return !(((_a = node2.meta) == null ? void 0 : _a.order) === false);
    });
  }
  get hasComponent() {
    return !!(this.module || this.asyncModule);
  }
  async getRawComponent() {
    const module = await this.loadModule();
    return module == null ? void 0 : module.default;
  }
  async loadModule() {
    if (!this.module && this.asyncModule) {
      let childPromises = [];
      if (this.meta.bundle || typeof window === "undefined")
        childPromises = this.navigableChildren.map((c) => c.loadModule());
      [this.module] = await Promise.all([this.asyncModule(), ...childPromises]);
    }
    return this.module;
  }
  get component() {
    const node2 = this;
    return function(options) {
      options.props = {
        ...options.props,
        passthrough: options.props,
        node: node2
      };
      return new Node_default({ ...options });
    };
  }
  get _fallback() {
    var _a;
    return this.children.find((node2) => node2.meta.fallback) || ((_a = this.parent) == null ? void 0 : _a._fallback);
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/UrlParamUtils.js
var defaultRe = /\[(.+?)\]/gm;
var UrlParamUtils = class {
  constructor(RE = defaultRe) {
    __publicField(this, "getFieldsFromName", (name) => [...name.matchAll(this.RE)].map((v) => v[1]));
    __publicField(this, "getRegexFromName", (name) => new RegExp("^" + name.replace(this.RE, "(.+)") + "$"));
    __publicField(this, "getValuesFromPath", (re, path) => (path.match(re) || []).slice(1));
    __publicField(this, "mapFieldsWithValues", (fields, values) => this.haveEqualLength(fields, values) && fields.reduce((map, field, index) => {
      map[field] = values[index];
      return map;
    }, {}));
    __publicField(this, "haveEqualLength", (fields, values) => {
      if (fields.length !== values.length)
        throw new Error(
          `fields and values should be of same length
fields: ${JSON.stringify(fields)}
values: ${JSON.stringify(values)}`
        );
      return true;
    });
    this.RE = RE;
  }
};

// node_modules/@roxi/routify/lib/common/Routify.js
var Routify = class {
  constructor() {
    __publicField(this, "NodeConstructor");
    __publicField(this, "NodeType");
    __publicField(this, "nodeIndex", []);
    __publicField(this, "rootNodes", {});
    __publicField(this, "utils", new UrlParamUtils());
  }
  createNode(name, module) {
    return new this.NodeConstructor(name, module, this);
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/RoutifyRuntime.js
var RoutifyRuntime = class extends Routify {
  constructor(options) {
    super();
    __publicField(this, "NodeConstructor", RNodeRuntime);
    __publicField(this, "mode", "runtime");
    __publicField(this, "routers", []);
    __publicField(this, "rootNodes", {});
    this.options = options;
    if (options.routes) {
      this.rootNodes[options.routes.rootName || "unnamed"] = this.createNode(
        options.routes.rootName
      ).importTree(options.routes);
    }
    this.global = appInstance.register(this);
    Object.defineProperty(this, "routers", { enumerable: false });
    this.log = this.global.log;
  }
};

// node_modules/hookar/esm/util.mjs
var runOnce = (cb) => {
  let hasRun;
  const wrapper = (...params2) => {
    if (hasRun)
      return;
    hasRun = true;
    return cb(...params2);
  };
  return wrapper;
};

// node_modules/hookar/esm/index.mjs
var createHooksCollection = (runner) => {
  const hooks = [];
  const hooksCollection = (hook) => {
    hooks.push(hook);
    return () => hooks.splice(hooks.indexOf(hook), 1);
  };
  hooksCollection.hooks = hooks;
  hooksCollection.run = runner(hooks);
  hooksCollection.runOnce = runOnce(runner(hooks));
  return hooksCollection;
};
var createPipelineCollection = (type) => createHooksCollection(
  (hooks) => (value, ...rest) => hooks.reduce(
    (pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => hook(r, ...rest)) : hook(pipedValue, ...rest),
    value
  )
);
var createSequenceHooksCollection = (type) => createHooksCollection(
  (hooks) => (value, ...rest) => hooks.reduce(
    (last, hook) => (last == null ? void 0 : last.then) ? last.then((_) => hook(value, ...rest)) : hook(value, ...rest),
    value
  )
);
var createGuardsCollection = (type) => createHooksCollection(
  (hooks) => (value, ...rest) => hooks.reduce(
    (pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => r && hook(value, ...rest)) : pipedValue && hook(value, ...rest),
    value || true
  )
);

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Address.js
var AddressReflector = class extends BaseReflector {
  constructor(router) {
    super(router);
    __publicField(this, "reflect", () => {
      const { mode } = get_store_value(this.router.activeRoute);
      if (mode === "popState")
        return false;
      const { routers, browserAdapter } = this.router.instance.global;
      const addressRouters = routers.filter(
        (router) => router.urlReflector instanceof this.constructor
      );
      const url2 = browserAdapter.toBrowser(addressRouters) || "/";
      this.log.debug("pushing internal url to browser history", {
        mode,
        url: url2,
        currentBrowserUrl: urlFromAddress(),
        currentInternalUrl: this.router.url.internal()
      });
      history[`${mode}Native`]({}, "", url2);
    });
    const { instance: instance8, urlRewrites } = router;
    const { urlFromBrowser, browserAdapter } = instance8.global;
    if (!history["onPushstate"]) {
      this.log.debug("polyfill history hooks");
      polyfillHistory();
    }
    const createStateEventHandler = (method) => {
      return function(data, title, url2) {
        var _a, _b;
        const routerName = (_b = (_a = data == null ? void 0 : data.routify) == null ? void 0 : _a.router) != null ? _b : false;
        if (routerName === false)
          url2 = browserAdapter.toRouter(url2, router);
        else if (routerName !== router.name)
          return false;
        for (const rewrite of urlRewrites)
          url2 = rewrite.toInternal(url2, { router });
        router.url[method](url2);
      };
    };
    this.absorb = () => router.url.replace(urlFromBrowser(router));
    this._pushstateHandler = createStateEventHandler("push");
    this._replacestateHandler = createStateEventHandler("replace");
    this._popstateHandler = () => router.url.pop(urlFromBrowser(router));
  }
  install() {
    this.hooks = [
      history["onPushstate"](this._pushstateHandler),
      history["onReplacestate"](this._replacestateHandler),
      history["onPopstate"](this._popstateHandler)
    ];
    if (!get_store_value(this.router.activeRoute))
      this.absorb();
    else
      this.reflect();
  }
  uninstall() {
    this.hooks.forEach((unreg) => unreg());
    setTimeout(() => this.reflect());
  }
};
function polyfillHistory() {
  const hooks = {
    onPushstate: createSequenceHooksCollection(),
    onReplacestate: createSequenceHooksCollection(),
    onPopstate: createSequenceHooksCollection()
  };
  Object.assign(history, hooks);
  const { pushState, replaceState } = history;
  history["pushStateNative"] = pushState;
  history["replaceStateNative"] = replaceState;
  history.pushState = hooks.onPushstate.run;
  history.replaceState = hooks.onReplacestate.run;
  window.addEventListener("popstate", hooks.onPopstate.run);
  return true;
}

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Internal.js
var InternalReflector = class extends BaseReflector {
  install() {
    this.router.url.replace("/");
  }
};

// node_modules/@roxi/routify/lib/runtime/plugins/reset/index.js
var parseModuleName = (str) => {
  const matches = str.match(/^(.+?)(\+)?$/);
  const [, name, prepend] = matches;
  return { name, prepend };
};
var createHandlers = (fragments, route) => {
  const getIndexOf = (fragment) => fragments.indexOf(fragment);
  const handlers = {
    boolean(_bool, fragment) {
      const index = getIndexOf(fragment);
      return handlers.number(index, fragment);
    },
    number(num, fragment) {
      const index = fragments.indexOf(fragment);
      const start = index - num;
      fragments.splice(start, num);
    },
    string(str, fragment) {
      const selfIndex = getIndexOf(fragment);
      const precedingFragments = fragments.slice(0, selfIndex + 1);
      let nextFragment;
      const { name, prepend } = parseModuleName(str);
      while (precedingFragments.length) {
        nextFragment = precedingFragments.pop();
        const matchingSiblingNode = nextFragment.node.children.find(
          (node2) => node2.meta.moduleName === name
        );
        if (matchingSiblingNode) {
          if (!prepend)
            fragments.splice(0, getIndexOf(fragment));
          fragments.unshift(route.createFragment(matchingSiblingNode));
          precedingFragments.splice(0);
        }
      }
    }
  };
  return handlers;
};
var handleFragment = (handlers) => (fragment) => {
  const { reset } = fragment.node.meta;
  if (reset)
    handlers[typeof reset](reset, fragment);
};
var reset_default = () => ({
  transformFragments: (_fragments) => {
    const { route } = _fragments[0];
    const fragments = [..._fragments];
    const handlers = createHandlers(fragments, route);
    _fragments.forEach(handleFragment(handlers));
    return fragments;
  }
});

// node_modules/@roxi/routify/lib/runtime/plugins/stripTrailingIndex/index.js
var stripTrailingIndex_default = () => ({
  urlRewrite: [
    {
      toExternal: (url2) => url2.replace(/\/index(?=$|\?|#)/, ""),
      toInternal: (url2) => url2
    }
  ]
});

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/utils.js
function findNextScrollableAncestor(element2, boundaryElements = []) {
  const isScrollable = (elem) => elem.scrollWidth > elem.clientWidth || elem.scrollHeight > elem.clientHeight;
  if (element2.parentElement && !boundaryElements.includes(element2) && !element2.dataset.hasOwnProperty("routifyScrollLock")) {
    if (isScrollable(element2.parentElement) || element2.parentElement === document.documentElement) {
      return element2.parentElement;
    } else {
      return findNextScrollableAncestor(element2.parentElement, boundaryElements);
    }
  } else {
    return null;
  }
}
function waitForScrollToComplete(elem) {
  let counter = 0;
  let lastPos = null;
  return new Promise((resolve) => {
    requestAnimationFrame(checkPos);
    function checkPos() {
      const { top, left } = elem.getBoundingClientRect();
      const newPos = top + "/" + left;
      counter++;
      if (newPos === lastPos && counter > 2) {
        resolve();
      } else {
        lastPos = newPos;
        requestAnimationFrame(checkPos);
      }
    }
  });
}
var observeDocument = (callback, runOnInit, timeout) => {
  if (runOnInit)
    callback();
  new ResizeObserver(() => {
  });
  const observer = new MutationObserver((mutations) => {
    const mutationsHasAddedOrRemovedANode = mutations.some(
      (mutation) => mutation.type === "childList" || mutation.type === "characterData"
    );
    if (mutationsHasAddedOrRemovedANode)
      callback();
  });
  observer.observe(document.body, {
    childList: true,
    subtree: true,
    characterData: true
  });
  if (timeout)
    setTimeout(() => observer.disconnect(), timeout);
  return observer;
};
var backupScrollBehavior = (elem) => {
  elem.oldBehavior = elem.oldBehavior || elem.style.scrollBehavior;
};
var restoreScrollBehavior = (elem) => {
  if (elem.oldBehavior)
    elem.style.scrollBehavior = elem.oldBehavior;
  else
    elem.style.removeProperty("scroll-behavior");
  delete elem.oldBehavior;
};
var getAllAncestors = (elem) => {
  const ancestors = [];
  let parent = elem.parentElement;
  while (parent) {
    ancestors.push(parent);
    parent = parent.parentElement;
  }
  return ancestors;
};

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/ScrollContext.js
var ScrollContext = class {
  constructor(context2) {
    __publicField(this, "elem");
    __publicField(this, "ctx");
    __publicField(this, "isInstant");
    __publicField(this, "scrollTarget");
    this.ctx = context2;
  }
  async getBoundary() {
    return resolveIfAnonFn(this.ctx.scrollBoundary, [this.ctx, this.scrollTarget]);
  }
  async init() {
    var _a, _b, _c, _d, _e;
    const { ctx } = this;
    const { anchor, parent } = await waitFor(ctx.elem, Boolean);
    this.scrollTarget = anchor || parent;
    const hashElem = ((_a = ctx.route) == null ? void 0 : _a.hash) && ((_c = globalThis.document) == null ? void 0 : _c.getElementById((_b = ctx.route) == null ? void 0 : _b.hash));
    this.elem = hashElem || this.scrollTarget;
    this.scrollToElem = ctx.isInline || ((_d = ctx.route) == null ? void 0 : _d.hash);
    this.isInstant = ((_e = ctx.route) == null ? void 0 : _e.state.dontsmoothscroll) || !ctx.wasVisible;
  }
  async handleScrollInstructions() {
    const { elem, isInstant, ctx } = this;
    const { scrollIntoView } = ctx.inline;
    const ancestors = getAllAncestors(elem);
    ancestors.forEach(backupScrollBehavior);
    if (isInstant)
      ancestors.forEach((ancestor) => ancestor.style.scrollBehavior = "auto");
    const observer = observeDocument(() => scrollIntoView(elem, isInstant), true);
    const timeout = isInstant ? 300 : 0;
    setTimeout(() => {
      observer.disconnect();
      ancestors.forEach(restoreScrollBehavior);
    }, timeout);
    return waitForScrollToComplete(elem);
  }
};

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/ScrollQueue.js
var defaultShouldScrollCallback = (_scrollContext, index, ScrollContexts) => index === ScrollContexts.length - 1;
var ScrollQueue = class {
  constructor() {
    __publicField(this, "queue", []);
  }
  push(scrollContext) {
    var _a;
    if (scrollContext.ctx.route != ((_a = this.queue[0]) == null ? void 0 : _a.ctx.route))
      this.queue = [];
    this.queue.push(scrollContext);
  }
  async processQueue() {
    this.queue = this.queue.filter(
      (scrollContext, index, arr) => scrollContext.ctx.inline.shouldScroll(
        scrollContext,
        index,
        arr,
        defaultShouldScrollCallback
      )
    );
    while (this.queue.length) {
      const scrollContext = this.queue.shift();
      await scrollContext.handleScrollInstructions();
    }
  }
};
var scrollQueue = new ScrollQueue();

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/scroll.js
var scrollToContext = async (context2) => {
  const scrollContext = new ScrollContext(context2);
  await scrollContext.init();
  if (!scrollContext.elem)
    ;
  else if (scrollContext.scrollToElem) {
    scrollQueue.push(scrollContext);
  } else
    scrollToTop(scrollContext.elem, await scrollContext.getBoundary());
};
var scrollToTop = (elem, boundary) => {
  let parent = findNextScrollableAncestor(elem, [boundary]);
  while (parent) {
    const oldBehavior = parent.style.scrollBehavior;
    parent.style.scrollBehavior = "auto";
    parent.scrollTo(0, 0);
    parent.style.scrollBehavior = oldBehavior;
    parent = findNextScrollableAncestor(parent, [boundary]);
  }
};

// node_modules/@roxi/routify/lib/runtime/renderer/utils/index.js
var getLineage = (context2) => {
  const contexts2 = [];
  while (context2) {
    contexts2.push(context2);
    context2 = context2.parentContext;
  }
  return contexts2;
};

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/ScrollDecorator.svelte
function create_fragment2(ctx) {
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let route;
  let router;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScrollDecorator", slots, ["default"]);
  let { context: context2 } = $$props;
  let { isRoot } = $$props;
  isRoot;
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<ScrollDecorator> was created without expected prop 'context'");
    }
    if (isRoot === void 0 && !("isRoot" in $$props || $$self.$$.bound[$$self.$$.props["isRoot"]])) {
      console.warn("<ScrollDecorator> was created without expected prop 'isRoot'");
    }
  });
  const writable_props = ["context", "isRoot"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScrollDecorator> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("isRoot" in $$props2)
      $$invalidate(1, isRoot = $$props2.isRoot);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    get: get_store_value,
    scrollToContext,
    getLineage,
    context: context2,
    isRoot,
    router,
    route
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("isRoot" in $$props2)
      $$invalidate(1, isRoot = $$props2.isRoot);
    if ("router" in $$props2)
      $$invalidate(2, router = $$props2.router);
    if ("route" in $$props2)
      $$invalidate(3, route = $$props2.route);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(3, { route, router } = context2, route, ($$invalidate(2, router), $$invalidate(0, context2)));
    }
    if ($$self.$$.dirty & 13) {
      $:
        if (route && !route.state.dontScroll) {
          if (route.hash && route.leaf === context2.fragment) {
            scrollToContext(context2);
          } else if ((get_store_value(router.activeRoute).leaf.node === context2.node || getLineage(context2).every((ctx) => get_store_value(ctx.isActive))) && context2 !== ((_a = context2.parentContext) == null ? void 0 : _a.lastActiveChildContext))
            scrollToContext(context2);
        }
    }
  };
  return [context2, isRoot, router, route, $$scope, slots];
}
var ScrollDecorator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { context: 0, isRoot: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScrollDecorator",
      options,
      id: create_fragment2.name
    });
  }
  get context() {
    throw new Error("<ScrollDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<ScrollDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isRoot() {
    throw new Error("<ScrollDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isRoot(value) {
    throw new Error("<ScrollDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScrollDecorator_default = ScrollDecorator;

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/plugin.js
var plugin_default = () => ({
  onMount: ({ context: context2 }) => {
    context2.decorators.push(ScrollDecorator_default);
  },
  afterRouteRendered: () => scrollQueue.processQueue()
});

// node_modules/@roxi/routify/lib/runtime/Router/utils/index.js
var normalizeRouterOptions = (options, config) => {
  config = config || {
    name: "",
    beforeRouterInit: [],
    afterRouterInit: [],
    urlRewrite: [],
    beforeUrlChange: [],
    afterUrlChange: [],
    afterRouteRendered: [],
    transformFragments: [],
    onMount: [],
    onDestroy: []
  };
  const { plugins, ...optionsOnly } = options;
  const optionsGroups = [...plugins || [], optionsOnly];
  optionsGroups.forEach((pluginOptions) => {
    var _a;
    (_a = pluginOptions.plugins) == null ? void 0 : _a.forEach((plugin) => normalizeRouterOptions(plugin, config));
    delete pluginOptions.plugins;
    Object.entries(pluginOptions).forEach(([field, value]) => {
      if (Array.isArray(config[field]))
        config[field].push(...[value].flat().filter(Boolean));
      else
        config[field] = value || config[field];
    });
  });
  return config;
};

// node_modules/@roxi/routify/lib/runtime/Router/Router.js
var stripNullFields = (obj) => Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
var defaultPlugins = [reset_default(), plugin_default(), stripTrailingIndex_default()];
var Router = class {
  constructor(input) {
    __publicField(this, "pendingRoute", getable(null));
    __publicField(this, "activeRoute", getable(null));
    __publicField(this, "_urlReflector", null);
    __publicField(this, "urlRewrites", []);
    __publicField(this, "beforeRouterInit", createSequenceHooksCollection());
    __publicField(this, "afterRouterInit", createSequenceHooksCollection());
    __publicField(this, "beforeUrlChange", createGuardsCollection());
    __publicField(this, "afterUrlChange", createSequenceHooksCollection());
    __publicField(this, "afterRouteRendered", createSequenceHooksCollection());
    __publicField(this, "transformFragments", createPipelineCollection());
    __publicField(this, "onMount", createSequenceHooksCollection());
    __publicField(this, "onDestroy", createSequenceHooksCollection());
    __publicField(this, "parentElem", null);
    __publicField(this, "queryHandler", {
      parse: (search, route) => URIDecodeObject(fromEntries(new URLSearchParams(search))),
      stringify: (params2, route) => {
        const query = new URLSearchParams(params2).toString();
        return query ? `?${query}` : "";
      }
    });
    __publicField(this, "clickHandler", {});
    __publicField(this, "url", {
      internal: () => this.url.getPending() || this.url.getActive(),
      external: () => this.getExternalUrl(),
      getActive: () => {
        var _a;
        return (_a = get_store_value(this.activeRoute)) == null ? void 0 : _a.url;
      },
      getPending: () => {
        var _a;
        return (_a = get_store_value(this.pendingRoute)) == null ? void 0 : _a.url;
      },
      toString: () => this.url.internal(),
      set: this._setUrl.bind(this),
      push: (url2, state = {}) => this._setUrl(url2, "pushState", false, state),
      replace: (url2, state = {}) => this._setUrl(url2, "replaceState", false, state),
      pop: (url2, state = {}) => this._setUrl(url2, "popState", false, state)
    });
    __publicField(this, "ready", async () => !this.pendingRoute.get() && this.activeRoute.get() || next(this.activeRoute, (x) => !!x));
    __publicField(this, "history", []);
    __publicField(this, "setParentElem", (elem) => {
      this.parentElem = elem;
    });
    __publicField(this, "getExternalUrl", (url2) => {
      const route = get_store_value(this.pendingRoute) || get_store_value(this.activeRoute);
      url2 = url2 || route.url;
      const result = this.urlRewrites.reduce(
        (_url2, rewrite) => rewrite.toExternal(_url2, { router: this }),
        url2
      );
      return result.replace(/\/index$/, "");
    });
    __publicField(this, "getInternalUrl", (url2) => this.urlRewrites.reduce(
      (_url2, rewrite) => rewrite.toInternal(_url2, { router: this }),
      url2
    ));
    const matchingRouter = appInstance.routers.find((r) => r.name == (input.name || ""));
    if (matchingRouter) {
      matchingRouter.init(input);
      return matchingRouter;
    }
    this.parentCmpCtx = getRoutifyFragmentContextMaybe();
    const { subscribe: subscribe2, set } = writable(this);
    this.subscribe = subscribe2;
    this.triggerStore = () => set(this);
    this.init(input);
    this.params = derived(this.activeRoute, ($activeRoute) => $activeRoute.params);
    this.afterUrlChange(() => setTimeout(() => this._urlReflector.reflect()));
    this.activeRoute.get = () => get_store_value(this.activeRoute);
    this.pendingRoute.get = () => get_store_value(this.pendingRoute);
  }
  init(input) {
    var _a, _b, _c, _d, _e;
    const firstInit = !this.options;
    input.plugins = [...defaultPlugins, ...input.plugins || []].filter(Boolean);
    input = stripNullFields(input);
    this.options = normalizeRouterOptions({ ...this.options, ...input });
    let {
      instance: instance8,
      rootNode,
      name,
      routes,
      urlRewrite,
      urlReflector,
      url: url2,
      passthrough,
      beforeUrlChange: beforeUrlChange2,
      afterUrlChange: afterUrlChange2,
      afterRouteRendered,
      transformFragments,
      onMount: onMount2,
      onDestroy: onDestroy2,
      beforeRouterInit,
      afterRouterInit,
      queryHandler,
      clickHandler
    } = this.options;
    if (queryHandler)
      this.queryHandler = queryHandler;
    if (clickHandler)
      this.clickHandler = clickHandler;
    beforeUrlChange2.forEach(this.beforeUrlChange);
    transformFragments.forEach(this.transformFragments);
    afterUrlChange2.forEach(this.afterUrlChange);
    afterRouteRendered.forEach(this.afterRouteRendered);
    onMount2.forEach(this.onMount);
    onDestroy2.forEach(this.onDestroy);
    beforeRouterInit.forEach(this.beforeRouterInit);
    afterRouterInit.forEach(this.afterRouterInit);
    this.beforeRouterInit.run({ router: this, firstInit });
    this.instance = instance8 || this.instance || ((_c = (_b = (_a = this.parentCmpCtx) == null ? void 0 : _a.route) == null ? void 0 : _b.router) == null ? void 0 : _c.instance) || appInstance.instances[0] || new RoutifyRuntime({});
    this.name = name != null ? name : this.name;
    this.urlRewrites = urlRewrite != null ? urlRewrite : this.urlRewrites;
    this.log = this.log || this.instance.log.createChild(this.name || "[unnamed instance]");
    if (passthrough && !(passthrough instanceof Router))
      passthrough = ((_d = this.parentCmpCtx) == null ? void 0 : _d.route.router) || passthrough;
    this.passthrough = passthrough || this.passthrough;
    appInstance.instances.forEach((inst) => {
      const index = inst.routers.indexOf(this);
      if (index !== -1)
        inst.routers.splice(index, 1);
    });
    this.instance.routers.push(this);
    if (routes && !this.rootNode)
      this.importRoutes(routes);
    this.rootNode = (_e = rootNode != null ? rootNode : this.rootNode) != null ? _e : this.instance.rootNodes[this.name || "default"];
    this.log.debug("initiated router");
    if (this.url.getActive()) {
      this.log.debug("router was created with activeUrl");
      this._setUrl(this.url.getActive(), "pushState", true);
    }
    const shouldInstallUrlReflector = !this.urlReflector || urlReflector && !(this.urlReflector instanceof urlReflector);
    if (shouldInstallUrlReflector) {
      urlReflector = urlReflector || (typeof window != "undefined" ? AddressReflector : InternalReflector);
      this.setUrlReflector(urlReflector);
    }
    if (url2)
      this.url.replace(url2);
    this.triggerStore();
    this.afterRouterInit.run({ router: this, firstInit });
  }
  importRoutes(routes) {
    this.rootNode = this.instance.createNode().importTree(routes);
    this.instance.rootNodes[routes.rootName || "unnamed"] = this.rootNode;
  }
  async _setUrl(url2, mode, isInternal, state = {}) {
    if (!isInternal)
      url2 = this.getInternalUrl(url2);
    url2 = url2 || "/";
    url2 = url2.replace(/(.+)\/+([#?]|$)/, "$1$2");
    this.log.debug("set url", {
      url: url2,
      mode,
      prev: this.url.internal(),
      browserOld: globalThis.document && urlFromAddress(),
      state
    });
    const currentRoute = this.pendingRoute.get() || this.activeRoute.get();
    if (!this.rootNode && this.instance.global.routeMaps[this.name])
      this.importRoutes(await this.instance.global.routeMaps[this.name]());
    const route = new Route(this, url2, mode, state);
    const loadRoutePromise = route.loadRoute();
    if (state.prefetch)
      return;
    if (identicalRoutes(currentRoute, route)) {
      this.log.debug("current route is identical - skip", currentRoute, route);
      return false;
    } else {
      route.log.debug("set pending route", route);
      this.pendingRoute.set(route);
      const didLoadRoute = await loadRoutePromise;
      if (this.pendingRoute.get() === route)
        this.pendingRoute.set(null);
      if (didLoadRoute)
        this.setActiveRoute(route);
      await new Promise((resolve) => setTimeout(resolve));
      return true;
    }
  }
  setActiveRoute(route) {
    this.log.debug("set active route", this);
    const $activeRoute = this.activeRoute.get();
    if ($activeRoute)
      this.history.push($activeRoute);
    this.activeRoute.set(route);
    this.afterUrlChange.run({
      route,
      history: [...this.history].reverse()
    });
    Promise.all(
      route.fragments.map(
        (fragment) => fragment.renderContext.then((rc) => rc.mounted)
      )
    ).then(() => this.afterRouteRendered.run({ route }));
    this.log.debug("unset pending route", this);
  }
  destroy() {
    this.log.debug(`destroying router`);
    this.instance.routers = this.instance.routers.filter((router) => router !== this);
    this.onDestroy.run({ router: this });
  }
  get urlReflector() {
    return this._urlReflector;
  }
  setUrlReflector(UrlReflector) {
    var _a;
    (_a = this._urlReflector) == null ? void 0 : _a.uninstall();
    this._urlReflector = new UrlReflector(this);
    this._urlReflector.install();
    this.triggerStore();
  }
};
var createRouter = (options) => new Router(options);

// node_modules/@roxi/routify/lib/runtime/renderer/DecoratorWrapper.svelte
function create_else_block2(ctx) {
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(23:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[2].component;
  function switch_props(ctx2) {
    return {
      props: {
        context: ctx2[1],
        isRoot: ctx2[0],
        $$slots: { default: [create_default_slot2] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 2)
        switch_instance_changes.context = ctx2[1];
      if (dirty & 1)
        switch_instance_changes.isRoot = ctx2[0];
      if (dirty & 74) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & 4 && switch_value !== (switch_value = ctx2[2].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(17:0) {#if decorator}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(19:8) <svelte:self decorators={restOfDecorators} {context} isRoot={false}>",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let decoratorwrapper;
  let current;
  decoratorwrapper = new DecoratorWrapper({
    props: {
      decorators: ctx[3],
      context: ctx[1],
      isRoot: false,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(decoratorwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(decoratorwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(decoratorwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const decoratorwrapper_changes = {};
      if (dirty & 8)
        decoratorwrapper_changes.decorators = ctx2[3];
      if (dirty & 2)
        decoratorwrapper_changes.context = ctx2[1];
      if (dirty & 64) {
        decoratorwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      decoratorwrapper.$set(decoratorwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(decoratorwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(decoratorwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(decoratorwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(18:4) <svelte:component this={decorator.component} {context} {isRoot}>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DecoratorWrapper", slots, ["default"]);
  let { decorators = null } = $$props;
  let { isRoot = true } = $$props;
  let { context: context2 } = $$props;
  decorators = decorators || context2.decorators;
  let [decorator, ...restOfDecorators] = [...decorators];
  while (decorator && !(decorator == null ? void 0 : decorator.shouldRender({ context: context2, isRoot, decorators })))
    [decorator, ...restOfDecorators] = [...restOfDecorators];
  if (isRoot)
    onDestroy(() => context2.onDestroy.run());
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<DecoratorWrapper> was created without expected prop 'context'");
    }
  });
  const writable_props = ["decorators", "isRoot", "context"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DecoratorWrapper> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("decorators" in $$props2)
      $$invalidate(4, decorators = $$props2.decorators);
    if ("isRoot" in $$props2)
      $$invalidate(0, isRoot = $$props2.isRoot);
    if ("context" in $$props2)
      $$invalidate(1, context2 = $$props2.context);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    decorators,
    isRoot,
    context: context2,
    decorator,
    restOfDecorators
  });
  $$self.$inject_state = ($$props2) => {
    if ("decorators" in $$props2)
      $$invalidate(4, decorators = $$props2.decorators);
    if ("isRoot" in $$props2)
      $$invalidate(0, isRoot = $$props2.isRoot);
    if ("context" in $$props2)
      $$invalidate(1, context2 = $$props2.context);
    if ("decorator" in $$props2)
      $$invalidate(2, decorator = $$props2.decorator);
    if ("restOfDecorators" in $$props2)
      $$invalidate(3, restOfDecorators = $$props2.restOfDecorators);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [isRoot, context2, decorator, restOfDecorators, decorators, slots, $$scope];
}
var DecoratorWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { decorators: 4, isRoot: 0, context: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DecoratorWrapper",
      options,
      id: create_fragment3.name
    });
  }
  get decorators() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorators(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isRoot() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isRoot(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DecoratorWrapper_default = DecoratorWrapper;

// node_modules/@roxi/routify/lib/runtime/decorators/Noop.svelte
function create_fragment4(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Noop", slots, ["default"]);
  let { context: context2 = null } = $$props;
  let { Parent = null } = $$props;
  context2;
  Parent;
  const writable_props = ["context", "Parent"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Noop> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("Parent" in $$props2)
      $$invalidate(1, Parent = $$props2.Parent);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ context: context2, Parent });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("Parent" in $$props2)
      $$invalidate(1, Parent = $$props2.Parent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [context2, Parent, $$scope, slots];
}
var Noop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { context: 0, Parent: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Noop",
      options,
      id: create_fragment4.name
    });
  }
  get context() {
    throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Parent() {
    throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Parent(value) {
    throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Noop_default = Noop;

// node_modules/@roxi/routify/lib/runtime/decorators/AnchorDecorator.svelte
var { Error: Error_1, console: console_1 } = globals;
var file = "node_modules/@roxi/routify/lib/runtime/decorators/AnchorDecorator.svelte";
function create_else_block3(ctx) {
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let if_block0 = !ctx[2] && create_if_block_3(ctx);
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let if_block1 = !ctx[2] && create_if_block_2(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      if (!ctx2[2]) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(49:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let t;
  let current;
  let div_levels = [{ "data-routify-anchor-header": "" }, ctx[3]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      div = element("div");
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-routify-anchor-header": true });
      children(div).forEach(detach_dev);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 46, 4, 1551);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[8](div);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { "data-routify-anchor-header": "" },
        dirty & 8 && ctx2[3]
      ]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[8](null);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(46:32) ",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let div_levels = [{ "data-routify-anchor-parent": "" }, ctx[3]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-routify-anchor-parent": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 42, 4, 1419);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[7](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { "data-routify-anchor-parent": "" },
        dirty & 8 && ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(42:0) {#if location === 'wrapper'}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div;
  let div_levels = [
    { "data-routify-anchor-locator": "" },
    { class: "anchor" },
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-routify-anchor-locator": true,
        class: true
      });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 50, 8, 1668);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[9](div);
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { "data-routify-anchor-locator": "" },
        { class: "anchor" },
        dirty & 8 && ctx2[3]
      ]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(50:4) {#if !mounted}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-routify-anchor-backstop": true
      });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "anchor-backstop");
      attr_dev(div, "data-routify-anchor-backstop", "");
      add_location(div, file, 58, 19, 1844);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(59:4) {#if !mounted}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_if_block_1, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === "wrapper")
      return 0;
    if (ctx2[0] === "header")
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["location", "onMount"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnchorDecorator", slots, ["default"]);
  let { location: location2 } = $$props;
  let { onMount: onMount2 = (x) => x } = $$props;
  let elem;
  let mounted = false;
  const nextValidSibling = (elem2) => {
    const next2 = elem2.nextElementSibling;
    if ("routifyAnchorBackstop" in next2.dataset) {
      console.warn("found no children in", elem2.parentElement);
      throw new Error("AnchorLocation is set to firstChild, but no children were found");
    }
    return next2 && "routifyAnchorLocator" in next2.dataset ? nextValidSibling(next2) : next2;
  };
  onMount(async () => {
    if (mounted)
      return;
    if (location2 === "wrapper")
      onMount2(elem);
    else if (location2 === "parent")
      onMount2(elem.parentElement);
    else if (location2 === "header")
      onMount2(elem.parentElement, elem);
    else if (location2 === "firstChild") {
      const nextSib = nextValidSibling(elem);
      onMount2(elem.parentElement, nextSib);
    } else
      throw new Error(`Incorrect location provided. Got ${location2}`);
    $$invalidate(2, mounted = true);
  });
  $$self.$$.on_mount.push(function() {
    if (location2 === void 0 && !("location" in $$props || $$self.$$.bound[$$self.$$.props["location"]])) {
      console_1.warn("<AnchorDecorator> was created without expected prop 'location'");
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  function div_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("location" in $$new_props)
      $$invalidate(0, location2 = $$new_props.location);
    if ("onMount" in $$new_props)
      $$invalidate(4, onMount2 = $$new_props.onMount);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _onMount: onMount,
    location: location2,
    onMount: onMount2,
    elem,
    mounted,
    nextValidSibling
  });
  $$self.$inject_state = ($$new_props) => {
    if ("location" in $$props)
      $$invalidate(0, location2 = $$new_props.location);
    if ("onMount" in $$props)
      $$invalidate(4, onMount2 = $$new_props.onMount);
    if ("elem" in $$props)
      $$invalidate(1, elem = $$new_props.elem);
    if ("mounted" in $$props)
      $$invalidate(2, mounted = $$new_props.mounted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    location2,
    elem,
    mounted,
    $$restProps,
    onMount2,
    $$scope,
    slots,
    div_binding,
    div_binding_1,
    div_binding_2
  ];
}
var AnchorDecorator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { location: 0, onMount: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnchorDecorator",
      options,
      id: create_fragment5.name
    });
  }
  get location() {
    throw new Error_1("<AnchorDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set location(value) {
    throw new Error_1("<AnchorDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMount() {
    throw new Error_1("<AnchorDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMount(value) {
    throw new Error_1("<AnchorDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnchorDecorator_default = AnchorDecorator;

// node_modules/@roxi/routify/lib/runtime/renderer/RenderFragment.svelte
var file2 = "node_modules/@roxi/routify/lib/runtime/renderer/RenderFragment.svelte";
function create_if_block4(ctx) {
  let decoratorwrapper;
  let current;
  decoratorwrapper = new DecoratorWrapper_default({
    props: {
      context: ctx[0],
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(decoratorwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(decoratorwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(decoratorwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const decoratorwrapper_changes = {};
      if (dirty & 1)
        decoratorwrapper_changes.context = ctx2[0];
      if (dirty & 1048635) {
        decoratorwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      decoratorwrapper.$set(decoratorwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(decoratorwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(decoratorwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(decoratorwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(50:0) {#if $isVisible && !isAnonFn(NodeComponent)}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let compose;
  let current;
  compose = new ComposeFragments_default({
    props: {
      options: {
        inline: ctx[14] || ctx[15],
        decorator: ctx[16],
        props: ctx[13],
        options: ctx[18],
        scrollBoundary: ctx[19],
        anchor: ctx[17] || ctx[0].anchorLocation
      },
      context: ctx[0]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(compose.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(compose.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(compose, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const compose_changes = {};
      if (dirty & 1040385)
        compose_changes.options = {
          inline: ctx2[14] || ctx2[15],
          decorator: ctx2[16],
          props: ctx2[13],
          options: ctx2[18],
          scrollBoundary: ctx2[19],
          anchor: ctx2[17] || ctx2[0].anchorLocation
        };
      if (dirty & 1)
        compose_changes.context = ctx2[0];
      compose.$set(compose_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(compose.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(compose.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(compose, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(69:17) {#if $childFragments.length || ((hasInlineChildren || inline || multi) && !(inline || multi)?.single)}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  var _a;
  let if_block_anchor;
  let current;
  let if_block = (ctx[5].length || (ctx[4] || ctx[14] || ctx[15]) && !((_a = ctx[14] || ctx[15]) == null ? void 0 : _a.single)) && create_if_block_12(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (ctx2[5].length || (ctx2[4] || ctx2[14] || ctx2[15]) && !((_a2 = ctx2[14] || ctx2[15]) == null ? void 0 : _a2.single)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 49200) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(57:12) <svelte:component                 this={NodeComponent}                 {...compProps}                 {...context.props}                 {context}                 let:props                 let:inline                 let:multi                 let:decorator                 let:anchor                 let:options                 let:scrollBoundary                 >",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let switch_instance;
  let t;
  let div;
  let childMounted_action;
  let current;
  let mounted;
  let dispose;
  const switch_instance_spread_levels = [
    ctx[3],
    ctx[0].props,
    { context: ctx[0] }
  ];
  var switch_value = ctx[1];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: {
        default: [
          create_default_slot_2,
          ({ props, inline, multi, decorator, anchor, options, scrollBoundary }) => ({
            13: props,
            14: inline,
            15: multi,
            16: decorator,
            17: anchor,
            18: options,
            19: scrollBoundary
          }),
          ({ props, inline, multi, decorator, anchor, options, scrollBoundary }) => (props ? 8192 : 0) | (inline ? 16384 : 0) | (multi ? 32768 : 0) | (decorator ? 65536 : 0) | (anchor ? 131072 : 0) | (options ? 262144 : 0) | (scrollBoundary ? 524288 : 0)
        ]
      },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file2, 81, 12, 3480);
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(childMounted_action = ctx[9].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & 9 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 8 && get_spread_object(ctx2[3]),
        dirty & 1 && get_spread_object(ctx2[0].props),
        dirty & 1 && { context: ctx2[0] }
      ]) : {};
      if (dirty & 2089009) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & 2 && switch_value !== (switch_value = ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(55:8) <AnchorDecorator location={context.anchorLocation} onMount={initialize}>",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let anchordecorator;
  let current;
  anchordecorator = new AnchorDecorator_default({
    props: {
      location: ctx[0].anchorLocation,
      onMount: ctx[8],
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(anchordecorator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchordecorator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(anchordecorator, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const anchordecorator_changes = {};
      if (dirty & 1)
        anchordecorator_changes.location = ctx2[0].anchorLocation;
      if (dirty & 1048635) {
        anchordecorator_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchordecorator.$set(anchordecorator_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchordecorator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchordecorator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchordecorator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(54:4) <DecoratorWrapper {context}>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let show_if = ctx[2] && !isAnonFn(ctx[1]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block4(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 6)
        show_if = ctx2[2] && !isAnonFn(ctx2[1]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 6) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  var _a;
  let hasInlineChildren;
  let params2;
  let load;
  let compProps;
  let $isVisible;
  let $childFragments;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderFragment", slots, []);
  let { context: context2 } = $$props;
  const { isVisible, childFragments } = context2;
  validate_store(isVisible, "isVisible");
  component_subscribe($$self, isVisible, (value) => $$invalidate(2, $isVisible = value));
  validate_store(childFragments, "childFragments");
  component_subscribe($$self, childFragments, (value) => $$invalidate(5, $childFragments = value));
  let NodeComponent = ((_a = context2.node.module) == null ? void 0 : _a.default) || context2.node.asyncModule || Noop_default;
  setRoutifyFragmentContext(context2);
  const updateRenderContext = (elem, newMeta) => {
    var _a2;
    if (elem)
      elem["__routify_meta"] = {
        ...elem && elem["__routify_meta"],
        renderContext: {
          ...(_a2 = elem["__routify_meta"]) == null ? void 0 : _a2.renderContext,
          ...newMeta
        }
      };
    return elem;
  };
  const initialize = async (parent, anchor) => {
    context2.parentContext && await waitFor(context2.parentContext.elem, Boolean);
    context2.elem.set({ anchor, parent });
    parent = updateRenderContext(parent, { parent: context2 });
    if (anchor)
      anchor = updateRenderContext(anchor, { anchor: context2 });
  };
  const childMounted = () => {
    context2.mounted.resolve(context2);
    context2.router.log.verbose("render", context2.node.path, context2);
  };
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<RenderFragment> was created without expected prop 'context'");
    }
  });
  const writable_props = ["context"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RenderFragment> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
  };
  $$self.$capture_state = () => ({
    Compose: ComposeFragments_default,
    DecoratorWrapper: DecoratorWrapper_default,
    Noop: Noop_default,
    AnchorDecorator: AnchorDecorator_default,
    isAnonFn,
    setRoutifyFragmentContext,
    waitFor,
    context: context2,
    isVisible,
    childFragments,
    NodeComponent,
    updateRenderContext,
    initialize,
    childMounted,
    load,
    params: params2,
    compProps,
    hasInlineChildren,
    $isVisible,
    $childFragments
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("NodeComponent" in $$props2)
      $$invalidate(1, NodeComponent = $$props2.NodeComponent);
    if ("load" in $$props2)
      $$invalidate(10, load = $$props2.load);
    if ("params" in $$props2)
      $$invalidate(11, params2 = $$props2.params);
    if ("compProps" in $$props2)
      $$invalidate(3, compProps = $$props2.compProps);
    if ("hasInlineChildren" in $$props2)
      $$invalidate(4, hasInlineChildren = $$props2.hasInlineChildren);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(4, hasInlineChildren = context2.node.navigableChildren.some((child) => child.meta.inline));
    }
    if ($$self.$$.dirty & 7) {
      $:
        if (isAnonFn(NodeComponent) && $isVisible)
          context2.node.loadModule().then((r) => $$invalidate(1, NodeComponent = r.default));
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(11, { params: params2, load } = context2.fragment, params2, ($$invalidate(10, load), $$invalidate(0, context2)));
    }
    if ($$self.$$.dirty & 3073) {
      $:
        $$invalidate(3, compProps = {
          ...params2,
          ...load == null ? void 0 : load.props,
          ...context2.props
        });
    }
  };
  return [
    context2,
    NodeComponent,
    $isVisible,
    compProps,
    hasInlineChildren,
    $childFragments,
    isVisible,
    childFragments,
    initialize,
    childMounted,
    load,
    params2
  ];
}
var RenderFragment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { context: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderFragment",
      options,
      id: create_fragment6.name
    });
  }
  get context() {
    throw new Error("<RenderFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<RenderFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderFragment_default = RenderFragment;

// node_modules/@roxi/routify/lib/runtime/renderer/utils/normalizeInline.js
var coerceInlineInputToObject = (inlineInput) => {
  if (typeof inlineInput === "undefined")
    return {};
  return {
    isInline: () => !!inlineInput,
    ...inlineInput
  };
};
var normalizeInline = (inlineInput) => ({
  isInline: () => false,
  scrollIntoView: (elem) => elem.scrollIntoViewIfNeeded ? elem.scrollIntoViewIfNeeded() : elem.scrollIntoView(),
  context: "browser",
  params: {},
  ...inlineInput,
  shouldScroll: typeof inlineInput.shouldScroll === "function" ? inlineInput.shouldScroll : typeof inlineInput.shouldScroll === "undefined" ? (ctx, index, arr, defaultCallback) => defaultCallback(ctx, index, arr) : () => !!inlineInput.shouldScroll
});

// node_modules/@roxi/routify/lib/runtime/renderer/utils/normalizeDecorator.js
var decoratorDefaults = { recursive: true, shouldRender: () => true };
var normalizeDecorator = (decorator) => {
  if ("component" in decorator)
    return { ...decoratorDefaults, ...decorator };
  else
    return { ...decoratorDefaults, component: decorator };
};

// node_modules/@roxi/routify/lib/runtime/renderer/RenderContext.js
var shiftParams = (node2, pool) => {
  const params2 = {};
  node2.paramKeys.forEach((key) => {
    if (pool && key in pool) {
      params2[key] = pool[key].shift();
    }
  });
  return params2;
};
var RouterContext = class {
  constructor({ router }) {
    __publicField(this, "childContexts", writable([]));
    __publicField(this, "childFragments", writable([]));
    __publicField(this, "activeChildContext", writable(null));
    __publicField(this, "lastActiveChildContext", null);
    __publicField(this, "decorators", []);
    this.router = router;
    this.route = router.activeRoute.get();
  }
  buildChildContexts(options, newDecorators) {
    var _a;
    const { childFragments } = this;
    const {
      inline: rawInlineInputFromSlot,
      decorator,
      props,
      anchor: anchorLocation,
      options: contextOptions,
      scrollBoundary = defaultscrollBoundary
    } = options;
    const refNode = (_a = get_store_value(childFragments)[0]) == null ? void 0 : _a.node;
    const node2 = (this == null ? void 0 : this["node"]) || refNode.parent;
    const matches = node2 ? node2.children.filter(
      (_node) => _node === refNode || node2.navigableChildren.includes(_node)
    ) : [refNode];
    const children2 = matches.length ? matches : refNode ? [refNode] : [];
    const paramsPool = jsonClone((rawInlineInputFromSlot == null ? void 0 : rawInlineInputFromSlot["params"]) || {});
    Object.entries(paramsPool).forEach(([key, values]) => {
      const sourceIndex = children2.findIndex((node3) => node3.paramKeys.includes(key));
      const newChildNodes = new Array(values.length - 1).fill(children2[sourceIndex]);
      children2.splice(sourceIndex + 1, 0, ...newChildNodes);
    });
    const childContexts = children2.map(
      (node3) => new RenderContext({
        node: node3,
        paramsPool,
        rawInlineInputFromSlot,
        parentContext: this,
        newDecorators,
        contextOptions,
        scrollBoundary,
        anchorLocation,
        props
      })
    );
    this.childContexts.set(childContexts);
  }
  updateChildren() {
    const activeChildContext = get_store_value(this.activeChildContext);
    get_store_value(this.childContexts).forEach((context2) => context2.update(activeChildContext));
  }
};
var RenderContext = class extends RouterContext {
  constructor({
    node: node2,
    paramsPool,
    rawInlineInputFromSlot,
    parentContext,
    newDecorators,
    contextOptions,
    scrollBoundary,
    anchorLocation,
    router,
    props
  }) {
    super({ router: router || parentContext.router });
    __publicField(this, "anchorLocation", "parent");
    __publicField(this, "node");
    __publicField(this, "isActive", writable(false));
    __publicField(this, "isVisible", writable(false));
    __publicField(this, "wasVisible", false);
    __publicField(this, "isInline", false);
    __publicField(this, "inline");
    __publicField(this, "elem", writable(null));
    __publicField(this, "route");
    __publicField(this, "childContexts", writable([]));
    __publicField(this, "onDestroy", createSequenceHooksCollection());
    __publicField(this, "mounted", createDeferredPromise());
    __publicField(this, "routerContext");
    this.anchorLocation = anchorLocation || "parent";
    this.node = node2;
    this.props = props;
    if (!node2)
      console.trace("node");
    const params2 = shiftParams(node2, paramsPool);
    this.fragment = new RouteFragment(null, node2, null, params2);
    this.childFragments = writable(
      fetchIndexNode(node2) ? [new RouteFragment(null, fetchIndexNode(node2))] : []
    );
    this.params = writable({});
    this.inline = normalizeInline({
      ...coerceInlineInputToObject(rawInlineInputFromSlot),
      ...coerceInlineInputToObject(node2.meta.inline)
    });
    if (parentContext instanceof RenderContext) {
      this.routerContext = parentContext.routerContext;
      this.parentContext = parentContext;
    } else
      this.routerContext = parentContext;
    this.decorators = newDecorators;
    this.options = contextOptions || {};
    this.scrollBoundary = scrollBoundary;
  }
  get parentOrRouterContext() {
    return this.parentContext || this.routerContext;
  }
  get ancestors() {
    const ancestors = [];
    let context2 = this.parentContext;
    while (context2) {
      ancestors.push(context2);
      context2 = context2.parentContext;
    }
    return ancestors;
  }
  setToActive() {
    const parentContext = this.parentOrRouterContext;
    const [fragment, ...fragments] = get_store_value(parentContext.childFragments);
    this.fragment = fragment;
    this.childFragments.set(fragments);
    this.route = parentContext.route;
    fragment.renderContext.resolve(this);
    parentContext.lastActiveChildContext = get_store_value(parentContext.activeChildContext);
    parentContext.activeChildContext.set(this);
    this.isInline = this.inline.isInline(this.node, this);
  }
  update(activeSiblingContext) {
    this.router.log.verbose("updating renderContext", this.node.name);
    const environment = typeof window !== "undefined" ? "browser" : "ssr";
    this.isInline = this.inline.isInline(this.node, activeSiblingContext);
    const activeContextIsStandalone = activeSiblingContext && !activeSiblingContext.isInline;
    const envIsOkay = ["always", environment].includes(this.inline.context);
    const isIncluded = this.isInline && !activeContextIsStandalone && envIsOkay;
    const isDefault = !activeSiblingContext && this.node.name === "index";
    this.wasVisible = get_store_value(this.isVisible);
    lazySet(
      this.isActive,
      this === activeSiblingContext || !activeSiblingContext && this.node.meta.isDefault
    );
    lazySet(this.isVisible, get_store_value(this.isActive) || isIncluded || isDefault);
    if (!get_store_value(this.isVisible))
      this.elem.set(null);
    this.updateParams();
  }
  updateParams() {
    let context2 = this;
    const contexts2 = [];
    while (context2) {
      contexts2.push(context2);
      context2 = context2.parentContext;
    }
    contexts2.reverse();
    this.params.set(
      Object.assign({}, ...contexts2.map((context3) => context3.fragment.params))
    );
  }
};

// node_modules/@roxi/routify/lib/runtime/renderer/composeFragments.js
var contextHasMatchingFragmentAndParams = (f) => (c) => f.node === c.node && Object.entries(f.params).every(([key, value]) => c.fragment.params[key] === value);
var fetchIndexNode = (node2) => node2.navigableChildren.find((node3) => node3.name === "index");
var findDecorator = (node2) => node2 == null ? void 0 : node2.children.find((node3) => node3.name === "_decorator");
var addFolderDecorator = (decorators, context2) => {
  var _a, _b, _c;
  const folderDecorator = findDecorator(context2.node);
  if (!folderDecorator)
    return;
  if (!folderDecorator.module)
    return folderDecorator.loadModule().then(() => {
      console.warn(`Dynamic import of "${folderDecorator.id}" may cause issues.`);
      addFolderDecorator(decorators, context2);
    });
  const options = folderDecorator.module["decorator"] || {};
  decorators.push({
    component: folderDecorator.module["default"],
    recursive: (_b = (_a = options.recursive) != null ? _a : folderDecorator.meta.recursive) != null ? _b : true,
    shouldRender: (_c = options.shouldRender) != null ? _c : () => true
  });
};
function findNearestInlineContext(context2) {
  return context2 ? context2.isInline ? context2 : findNearestInlineContext(context2.parentContext) : null;
}
var defaultscrollBoundary = (ownContext) => {
  var _a, _b;
  return !ownContext.isInline && ((_b = get_store_value((_a = findNearestInlineContext(ownContext)) == null ? void 0 : _a.elem)) == null ? void 0 : _b.parent);
};
var findActiveChildContext = (childContexts, fragment) => childContexts.find(contextHasMatchingFragmentAndParams(fragment)) || childContexts.find((s) => s.node === (fragment == null ? void 0 : fragment.node));

// node_modules/@roxi/routify/lib/runtime/renderer/ComposeFragments.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_if_block5(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[2];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[0];
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4) {
        each_value = ctx2[2];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(67:0) {#if decoratorReady}",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let renderfragment;
  let current;
  renderfragment = new RenderFragment_default({
    props: { context: ctx[0] },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(renderfragment.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(renderfragment.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(renderfragment, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const renderfragment_changes = {};
      if (dirty & 4)
        renderfragment_changes.context = ctx[0];
      renderfragment.$set(renderfragment_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderfragment.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderfragment.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(renderfragment, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(68:4) {#each $childContexts as context (context)}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] && create_if_block5(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  var _a;
  let $childFragments;
  let $childContexts;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComposeFragments", slots, []);
  let { context: context2 } = $$props;
  let { options } = $$props;
  const { childFragments } = context2;
  validate_store(childFragments, "childFragments");
  component_subscribe($$self, childFragments, (value) => $$invalidate(6, $childFragments = value));
  const { decorator } = options;
  const recursiveDecorators = context2.decorators.filter((deco) => deco.recursive);
  const newDecorators = pushToOrReplace(recursiveDecorators, decorator).filter(Boolean).map(normalizeDecorator);
  let decoratorReady = !((_a = addFolderDecorator(newDecorators, context2)) == null ? void 0 : _a["then"](() => $$invalidate(1, decoratorReady = true)));
  context2.buildChildContexts(options, newDecorators);
  const { childContexts } = context2;
  validate_store(childContexts, "childContexts");
  component_subscribe($$self, childContexts, (value) => $$invalidate(2, $childContexts = value));
  const _handleChildren = (childFragments2) => {
    context2.router.log.verbose("handle children", childFragments2);
    const setInactive = (cf) => cf.renderContext.then((rc) => rc.isActive.set(false));
    if (childFragments2.length && context2.route)
      setActiveChildContext(context2);
    else
      childFragments2.forEach(setInactive);
    context2.updateChildren();
  };
  const setActiveChildContext = (context3, rebuild) => {
    const [fragment, ...childFragments2] = get_store_value(context3.childFragments);
    const childContexts2 = get_store_value(context3.childContexts);
    const toBeActiveChildContext = findActiveChildContext(childContexts2, fragment);
    if (!toBeActiveChildContext) {
      if (rebuild)
        handleRebuildError(context3, childContexts2);
      context3.buildChildContexts(options, newDecorators);
      return setActiveChildContext(context3, true);
    }
    toBeActiveChildContext.setToActive();
    context3.childContexts.set(childContexts2);
  };
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<ComposeFragments> was created without expected prop 'context'");
    }
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<ComposeFragments> was created without expected prop 'options'");
    }
  });
  const writable_props = ["context", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ComposeFragments> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("options" in $$props2)
      $$invalidate(5, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    get: get_store_value,
    pushToOrReplace,
    RenderFragment: RenderFragment_default,
    normalizeDecorator,
    handleRebuildError,
    addFolderDecorator,
    findActiveChildContext,
    context: context2,
    options,
    childFragments,
    decorator,
    recursiveDecorators,
    newDecorators,
    decoratorReady,
    childContexts,
    _handleChildren,
    setActiveChildContext,
    $childFragments,
    $childContexts
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("options" in $$props2)
      $$invalidate(5, options = $$props2.options);
    if ("decoratorReady" in $$props2)
      $$invalidate(1, decoratorReady = $$props2.decoratorReady);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      $:
        _handleChildren($childFragments);
    }
  };
  return [
    context2,
    decoratorReady,
    $childContexts,
    childFragments,
    childContexts,
    options,
    $childFragments
  ];
}
var ComposeFragments = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { context: 0, options: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComposeFragments",
      options,
      id: create_fragment7.name
    });
  }
  get context() {
    throw new Error("<ComposeFragments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<ComposeFragments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<ComposeFragments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<ComposeFragments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComposeFragments_default = ComposeFragments;

// node_modules/@roxi/routify/lib/runtime/Router/Router.svelte
function create_if_block6(ctx) {
  let component;
  let current;
  component = new ComposeFragments_default({
    props: {
      context: ctx[2],
      options: { decorator: ctx[0] }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(component.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(component.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(component, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const component_changes = {};
      if (dirty & 4)
        component_changes.context = ctx2[2];
      if (dirty & 1)
        component_changes.options = { decorator: ctx2[0] };
      component.$set(component_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(component.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(component.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(component, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(132:4) {#if $activeRoute}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[3] && create_if_block6(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: '(131:0) <AnchorDecorator onMount={initialize} style=\\"display: contents\\" location={anchor}>',
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let anchordecorator;
  let current;
  anchordecorator = new AnchorDecorator_default({
    props: {
      onMount: ctx[5],
      style: "display: contents",
      location: ctx[1],
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(anchordecorator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchordecorator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(anchordecorator, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const anchordecorator_changes = {};
      if (dirty & 2)
        anchordecorator_changes.location = ctx2[1];
      if (dirty & 134217741) {
        anchordecorator_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchordecorator.$set(anchordecorator_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchordecorator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchordecorator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchordecorator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let activeRoute2;
  let $activeRoute, $$unsubscribe_activeRoute = noop, $$subscribe_activeRoute = () => ($$unsubscribe_activeRoute(), $$unsubscribe_activeRoute = subscribe(activeRoute2, ($$value) => $$invalidate(3, $activeRoute = $$value)), activeRoute2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeRoute());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Router", slots, []);
  let { router = null } = $$props;
  let { routes = null } = $$props;
  let { decorator = null } = $$props;
  let { urlReflector = null } = $$props;
  let { instance: instance8 = null } = $$props;
  let { urlRewrite = null } = $$props;
  let { url: url2 = null } = $$props;
  let { name = null } = $$props;
  let { rootNode = null } = $$props;
  let { passthrough = null } = $$props;
  let { beforeRouterInit = null } = $$props;
  let { afterRouterInit = null } = $$props;
  let { beforeUrlChange: beforeUrlChange2 = null } = $$props;
  let { afterUrlChange: afterUrlChange2 = null } = $$props;
  let { transformFragments = null } = $$props;
  let { onDestroy: onDestroy2 = null } = $$props;
  let { plugins = null } = $$props;
  let { queryHandler = null } = $$props;
  let { anchor = "wrapper" } = $$props;
  let { clickHandler = {} } = $$props;
  const options = {
    instance: instance8,
    rootNode,
    name,
    routes,
    urlRewrite,
    urlReflector,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange: beforeUrlChange2,
    afterUrlChange: afterUrlChange2,
    transformFragments,
    onDestroy: onDestroy2,
    plugins,
    queryHandler,
    clickHandler
  };
  router = router || new Router(options);
  const context2 = new RouterContext({ router });
  router.onMount.run({ context: context2, router });
  context2.decorators = context2.decorators.map(normalizeDecorator);
  const initialize = (elem) => {
    var _a;
    elem = anchor === "parent" || anchor === "wrapper" ? elem : elem.parentElement;
    router.setParentElem(elem);
    elem["__routify_meta"] = { ...elem["__routify_meta"], router };
    let clickScopeElem = resolveIfAnonFn(((_a = router.clickHandler) == null ? void 0 : _a.elem) || elem, [elem]);
    if (!router.passthrough) {
      clickScopeElem.addEventListener("click", handleClick);
      clickScopeElem.addEventListener("keydown", handleClick);
      clickScopeElem.addEventListener("mouseover", handleHover);
    }
  };
  const handleHover = (event) => {
    var _a, _b, _c, _d;
    let { url: url3, state } = getUrlFromEvent(event);
    const urlOrFalse = (_c = (_b = (_a = router.clickHandler).callback) == null ? void 0 : _b.call(_a, event, url3)) != null ? _c : url3;
    const shouldPrefetch = typeof urlOrFalse === "string" && ((_d = event.target.closest("[data-routify-prefetch-data]")) == null ? void 0 : _d.dataset.routifyPrefetchData) === "hover";
    if (shouldPrefetch)
      router.url.push(urlOrFalse, { prefetch: true, ...state });
  };
  const handleClick = (event) => {
    var _a, _b, _c;
    if (shouldIgnoreClick(event))
      return;
    const { url: eventUrl, state } = getUrlFromEvent(event);
    const url3 = (_c = (_b = (_a = router.clickHandler).callback) == null ? void 0 : _b.call(_a, event, eventUrl)) != null ? _c : eventUrl;
    if (typeof url3 === "string")
      router.url.push(url3, state);
  };
  if (typeof window !== "undefined")
    onDestroy(() => router.destroy());
  const writable_props = [
    "router",
    "routes",
    "decorator",
    "urlReflector",
    "instance",
    "urlRewrite",
    "url",
    "name",
    "rootNode",
    "passthrough",
    "beforeRouterInit",
    "afterRouterInit",
    "beforeUrlChange",
    "afterUrlChange",
    "transformFragments",
    "onDestroy",
    "plugins",
    "queryHandler",
    "anchor",
    "clickHandler"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Router> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("router" in $$props2)
      $$invalidate(6, router = $$props2.router);
    if ("routes" in $$props2)
      $$invalidate(7, routes = $$props2.routes);
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("urlReflector" in $$props2)
      $$invalidate(8, urlReflector = $$props2.urlReflector);
    if ("instance" in $$props2)
      $$invalidate(9, instance8 = $$props2.instance);
    if ("urlRewrite" in $$props2)
      $$invalidate(10, urlRewrite = $$props2.urlRewrite);
    if ("url" in $$props2)
      $$invalidate(11, url2 = $$props2.url);
    if ("name" in $$props2)
      $$invalidate(12, name = $$props2.name);
    if ("rootNode" in $$props2)
      $$invalidate(13, rootNode = $$props2.rootNode);
    if ("passthrough" in $$props2)
      $$invalidate(14, passthrough = $$props2.passthrough);
    if ("beforeRouterInit" in $$props2)
      $$invalidate(15, beforeRouterInit = $$props2.beforeRouterInit);
    if ("afterRouterInit" in $$props2)
      $$invalidate(16, afterRouterInit = $$props2.afterRouterInit);
    if ("beforeUrlChange" in $$props2)
      $$invalidate(17, beforeUrlChange2 = $$props2.beforeUrlChange);
    if ("afterUrlChange" in $$props2)
      $$invalidate(18, afterUrlChange2 = $$props2.afterUrlChange);
    if ("transformFragments" in $$props2)
      $$invalidate(19, transformFragments = $$props2.transformFragments);
    if ("onDestroy" in $$props2)
      $$invalidate(20, onDestroy2 = $$props2.onDestroy);
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("queryHandler" in $$props2)
      $$invalidate(22, queryHandler = $$props2.queryHandler);
    if ("anchor" in $$props2)
      $$invalidate(1, anchor = $$props2.anchor);
    if ("clickHandler" in $$props2)
      $$invalidate(23, clickHandler = $$props2.clickHandler);
  };
  $$self.$capture_state = () => ({
    Router,
    _onDestroy: onDestroy,
    getUrlFromEvent,
    resolveIfAnonFn,
    shouldIgnoreClick,
    Component: ComposeFragments_default,
    get: get_store_value,
    AnchorDecorator: AnchorDecorator_default,
    normalizeDecorator,
    RouterContext,
    router,
    routes,
    decorator,
    urlReflector,
    instance: instance8,
    urlRewrite,
    url: url2,
    name,
    rootNode,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange: beforeUrlChange2,
    afterUrlChange: afterUrlChange2,
    transformFragments,
    onDestroy: onDestroy2,
    plugins,
    queryHandler,
    anchor,
    clickHandler,
    options,
    context: context2,
    initialize,
    handleHover,
    handleClick,
    activeRoute: activeRoute2,
    $activeRoute
  });
  $$self.$inject_state = ($$props2) => {
    if ("router" in $$props2)
      $$invalidate(6, router = $$props2.router);
    if ("routes" in $$props2)
      $$invalidate(7, routes = $$props2.routes);
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("urlReflector" in $$props2)
      $$invalidate(8, urlReflector = $$props2.urlReflector);
    if ("instance" in $$props2)
      $$invalidate(9, instance8 = $$props2.instance);
    if ("urlRewrite" in $$props2)
      $$invalidate(10, urlRewrite = $$props2.urlRewrite);
    if ("url" in $$props2)
      $$invalidate(11, url2 = $$props2.url);
    if ("name" in $$props2)
      $$invalidate(12, name = $$props2.name);
    if ("rootNode" in $$props2)
      $$invalidate(13, rootNode = $$props2.rootNode);
    if ("passthrough" in $$props2)
      $$invalidate(14, passthrough = $$props2.passthrough);
    if ("beforeRouterInit" in $$props2)
      $$invalidate(15, beforeRouterInit = $$props2.beforeRouterInit);
    if ("afterRouterInit" in $$props2)
      $$invalidate(16, afterRouterInit = $$props2.afterRouterInit);
    if ("beforeUrlChange" in $$props2)
      $$invalidate(17, beforeUrlChange2 = $$props2.beforeUrlChange);
    if ("afterUrlChange" in $$props2)
      $$invalidate(18, afterUrlChange2 = $$props2.afterUrlChange);
    if ("transformFragments" in $$props2)
      $$invalidate(19, transformFragments = $$props2.transformFragments);
    if ("onDestroy" in $$props2)
      $$invalidate(20, onDestroy2 = $$props2.onDestroy);
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("queryHandler" in $$props2)
      $$invalidate(22, queryHandler = $$props2.queryHandler);
    if ("anchor" in $$props2)
      $$invalidate(1, anchor = $$props2.anchor);
    if ("clickHandler" in $$props2)
      $$invalidate(23, clickHandler = $$props2.clickHandler);
    if ("activeRoute" in $$props2)
      $$subscribe_activeRoute($$invalidate(4, activeRoute2 = $$props2.activeRoute));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2112) {
      $:
        if (url2 && url2 !== router.url.internal())
          router.url.replace(url2);
    }
    if ($$self.$$.dirty & 64) {
      $:
        $$subscribe_activeRoute($$invalidate(4, activeRoute2 = router.activeRoute));
    }
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(2, context2.route = $activeRoute, context2);
    }
    if ($$self.$$.dirty & 12) {
      $:
        context2.childFragments.set(($activeRoute == null ? void 0 : $activeRoute.fragments) || []);
    }
    if ($$self.$$.dirty & 68) {
      $:
        router.log.debug("before render", get_store_value(context2.childFragments));
    }
  };
  return [
    decorator,
    anchor,
    context2,
    $activeRoute,
    activeRoute2,
    initialize,
    router,
    routes,
    urlReflector,
    instance8,
    urlRewrite,
    url2,
    name,
    rootNode,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange2,
    afterUrlChange2,
    transformFragments,
    onDestroy2,
    plugins,
    queryHandler,
    clickHandler
  ];
}
var Router_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment8, safe_not_equal, {
      router: 6,
      routes: 7,
      decorator: 0,
      urlReflector: 8,
      instance: 9,
      urlRewrite: 10,
      url: 11,
      name: 12,
      rootNode: 13,
      passthrough: 14,
      beforeRouterInit: 15,
      afterRouterInit: 16,
      beforeUrlChange: 17,
      afterUrlChange: 18,
      transformFragments: 19,
      onDestroy: 20,
      plugins: 21,
      queryHandler: 22,
      anchor: 1,
      clickHandler: 23
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router_1",
      options,
      id: create_fragment8.name
    });
  }
  get router() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set router(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routes() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routes(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decorator() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorator(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get urlReflector() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set urlReflector(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get urlRewrite() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set urlRewrite(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rootNode() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rootNode(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passthrough() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passthrough(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beforeRouterInit() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beforeRouterInit(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get afterRouterInit() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set afterRouterInit(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beforeUrlChange() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beforeUrlChange(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get afterUrlChange() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set afterUrlChange(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transformFragments() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transformFragments(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDestroy() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDestroy(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get plugins() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plugins(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryHandler() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryHandler(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clickHandler() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clickHandler(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Router_default = Router_1;

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/LocalStorage.js
var LocalStorageReflector = class extends BaseReflector {
  constructor(router) {
    super(router);
    this.storageName = `__routify-router-${this.router.name}`;
  }
  reflect() {
    window.localStorage.setItem(this.storageName, this.router.url.internal());
  }
  install() {
    const url2 = window.localStorage.getItem(this.storageName);
    this.router.url.replace(url2 || "/");
  }
};

// node_modules/@roxi/routify/lib/runtime/utils/killWarnings.js
var killWarnings = () => {
  var originalWarn = console.warn;
  console.warn = function() {
    var args = Array.prototype.slice.call(arguments);
    if (args[0].match(/<.+> was created with unknown prop 'context'/))
      return;
    if (args[0].match(/<.+> was created with unknown prop 'isRoot'/))
      return;
    if (args[0].match(/<.+> received an unexpected slot "default"\./))
      return;
    var stackTrace = new Error().stack;
    var callSite = stackTrace.split("\n")[2];
    if (callSite) {
      args.push(callSite.trim());
    }
    originalWarn.apply(console, args);
  };
};

// node_modules/@roxi/routify/lib/common/helpers.js
var gentleAssign = (target, ...sources) => {
  sources.forEach(
    (source) => Object.keys(source).forEach((key) => {
      var _a;
      return target[key] = (_a = target[key]) != null ? _a : source[key];
    })
  );
  return target;
};
var assignNode = (target, ...sources) => {
  gentleAssign(target, ...sources);
  gentleAssign(target.meta, ...sources.map((s) => s.meta));
  sources.forEach((source) => {
    source.children.forEach((sNode) => {
      let tNode = target.children.find((tNode2) => tNode2.name === sNode.name);
      if (!tNode)
        tNode = target.createChild(null, null);
      assignNode(tNode, sNode);
    });
  });
  return target;
};
var findNearestParent = (node2, callback) => {
  let parent = node2.parent;
  while (parent) {
    if (callback(parent))
      return parent;
    parent = parent.parent;
  }
};
var getDistance = (parentNode, childNode) => {
  let child = null;
  let distance = 0;
  while (child = childNode.parent) {
    distance++;
    if (parentNode === childNode)
      return distance;
  }
};

// node_modules/@roxi/routify/lib/runtime/index.js
killWarnings();
var Routify2 = RoutifyRuntime;
export {
  AddressReflector,
  ComposeFragments_default as Component,
  InternalReflector,
  LocalStorageReflector,
  Router_default as Router,
  Router as RouterClass,
  Routify2 as Routify,
  _url,
  activeRoute,
  afterUrlChange,
  appInstance,
  assignNode,
  beforeUrlChange,
  context,
  createRouter,
  createUrl,
  findNearestParent,
  getDistance,
  getMRCA,
  getPath,
  getPrimaryUrl,
  goto,
  isActive,
  isActiveFragment,
  isActiveUrl,
  meta,
  node,
  params,
  pendingRoute,
  preloadUrl,
  preloadUrlFromUrlPairs,
  resolveNode,
  traverseNode,
  url
};
//# sourceMappingURL=@roxi_routify.js.map
